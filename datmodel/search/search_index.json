{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Data model 2025","text":"<p>The last meaningful update to the LogiqX XML-based DAT format happened 28 October, 2008. Instead of modernizing an increasingly creaky standard, changes have been made ad-hoc by preservation groups and client applications to force new behaviors, resulting in the abuse of existing structures for unintended purposes, violating the standard, or the provision of sidecar metadata or services to enrich the DAT files to enable new use cases.</p> <p>This site proposes a new datafile standard that's designed from the beginning to provide additional structure and metadata, so that DAT applications can implement extended functionality. Because the structure has been created conceptually and is still work-in-progress, it's likely it will need to evolve as applications are built that parse it and test its capability.</p>"},{"location":"#proposal-details","title":"Proposal details","text":"<ul> <li> <p>Status: WIP</p> </li> <li> <p>Last updated: 2025-03-18</p> </li> <li> <p>Contributors: unexpectedpanda</p> </li> <li> <p>Potential stakeholders: gordonj, darksabre76, emmercm, Roman Scherzer, No-Intro,   Redump, TOSEC</p> </li> </ul>"},{"location":"1g1r/","title":"1G1R process","text":"<p>TBC</p>"},{"location":"addOns/","title":"<code>addOns</code>","text":"<p>The <code>addOns</code> array contains objects that represent add-ons, like downloadable content (DLC) for a <code>title</code>. You can bundle add-ons together, and assign them to specific sets.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"addOns\": [\n  {\n    \"name\": \"Some Video Game - DLC 2 (USA) (v1.2)\",\n    \"container\": \"auto\",\n    \"requiresId\": [\"123456\", \"456122\"],\n    \"id\": \"456123\",\n    \"comments\": \"Something relevant about the add-on\",\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"name\": \"Some Video Game - DLC 1 (USA)\",\n    \"container\": \"auto\",\n    \"requiresId\": [\"123456\"],\n    \"id\": \"456122\",\n    \"comments\": \"Something relevant about the add-on\",\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"name\": \"Some Video Game - DLC 2 (USA) (v1.1)\",\n    \"container\": \"auto\",\n    \"requiresId\": [\"123456\"],\n    \"superseded\": true,\n    \"id\": \"456121\",\n    \"comments\": \"Something relevant about the add-on\",\n    \"files\": [\n      ...\n    ]\n  }\n]\n</code></pre>"},{"location":"addOns/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the add-on, in UTF-8. This is used for the name of the archive or folder of the contained add-on:</p> <p>Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\|?*].*[^. :&lt;&gt;\\\"\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>files</code> <code>object array</code> <code>required</code></p> <p>The files in the add-on and their properties. Read more about the <code>files</code> array.</p> </li> </ul>"},{"location":"addOns/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>comments</code> <code>string</code> <code>optional</code></p> <p>Comments related to the add-on.</p> </li> <li> <p><code>container</code> <code>string</code> <code>optional</code></p> <p>The container that the DAT application should use for the file set. Must be one of the following values:</p> <ul> <li> <p><code>auto</code>: Store the files in whatever container the user chooses in the DAT   application. For example, a ZIP file, a 7Z file, a folder, or no container. The base   file name of the container matches the add-on <code>name</code>.</p> </li> <li> <p><code>folder</code>: Store the files in a folder named after the add-on   <code>name</code>.</p> </li> <li> <p><code>null</code>: Don't store the files in any container. Useful for keeping files by   themselves, or for treating archives as files.</p> </li> </ul> <p>If this property isn't present, the DAT application assumes the value is <code>auto</code>.</p> </li> <li> <p><code>id</code> <code>string</code> <code>optional</code></p> <p>A gobally unique ID for the add-on. Usually a database ID to ease lookups for DAT file maintainers. Might be referenced by a DAT application when finding dependencies for other add-ons, or when present in a <code>contains</code> array.</p> </li> <li> <p><code>requiresId</code> <code>string</code> <code>optional</code></p> <p>Which titles and updates the specific add-on requires to function, as identified by their globally unique IDs.</p> <p>This way if a title gets selected during filtering, its relevant add-ons can be selected too. Conversely, if a title gets filtered out, there's an opportunity to remove its add-ons as well.</p> <p>Add-ons are considered to be valid for all <code>sets</code>.</p> Expand for developer details <p>The most optimal behavior here is likely first walking the <code>addOns</code> array for the required ID, and then on a miss going up one level to <code>collections</code>, and walking the <code>titles</code> array for the required ID.</p> </li> <li> <p><code>superseded</code> <code>boolean</code> <code>optional</code></p> <p>Add-ons kept for archival purposes, that are no longer required to update a title to its latest version.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> </ul>"},{"location":"basic_example/","title":"Basic example","text":"<p>The following example represents a valid DAT file, with only the mandatory properties supplied.</p> <p>It doesn't include all available keys or demonstrate all valid values. For that, see the DAT file structures section.</p> <pre><code>{\n  \"datInfo\": {\n    \"schema\": \"https://www.github.com/unexpectedpanda/datmodel\",\n    \"name\": \"Company - Console\",\n    \"source\": \"Release group\",\n    \"date\": \"2025-12-30\"\n  },\n  \"collection\": [\n    {\n      \"group\": \"Some Video Game\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game (Japan)\",\n          \"regions\": [\"JP\"],\n          \"languages\": {\n            \"audio\": [\"ja\", \"en\"],\n            \"interface\": [\"ja\", \"en\"],\n            \"subtitles\": [\"en\"]\n          },\n          \"sets\": [\n            {\n              \"files\": [\n                {\n                  \"name\" : \"file.asd\",\n                  \"size\": 123,\n                  \"digests\": {\n                    \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n                  }\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"name\": \"Some Video Game (USA)\",\n          \"regions\": [\"US\"],\n          \"languages\": {\n            \"audio\": [\"en\"],\n            \"interface\": [\"en\"],\n            \"subtitles\": [\"en\"]\n          },\n          \"sets\": [\n            {\n              \"files\": [\n                {\n                  \"name\" : \"file.asd\",\n                  \"size\": 98,\n                  \"digests\": {\n                    \"blake3\": \"d6a38bd711fbfd1065c2f7907c631590ac56249613972199a19713d7c6f10b4d\"\n                  }\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"collection/","title":"<code>collection</code>","text":"<p>The <code>collection</code> array contains all of the titles in the DAT file.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"collection\": [\n  {\n    \"group\": \"Some Video Game\",\n    \"id\": \"654321\",\n    \"titles\": [\n      {\n        ...\n      }\n    ],\n    \"addOns\": [\n      {\n        ...\n      }\n    ],\n    \"updates\": [\n      {\n        ...\n      }\n    ]\n  }\n]\n</code></pre> <p>Related titles are grouped together in a single object by naming a <code>group</code> and listing its <code>titles</code>. For example, the group <code>Some Video Game</code> might contain the following titles:</p> <ul> <li><code>Some Video Game (Europe)</code></li> <li><code>Some Video Game (Japan)</code></li> <li><code>Some Video Game (USA)</code></li> <li><code>Some Video Game (USA) (v1.1)</code></li> <li><code>Some Video Game - Game of the Year Edition (Europe)</code></li> </ul> <p>The following updates:</p> <ul> <li><code>Some Video Game (Europe) (Update v1.2)</code></li> <li><code>Some Video Game (Japan) (Update v1.1)</code></li> </ul> <p>And the following add-ons:</p> <ul> <li><code>Some Video Game - Expansion Pack (USA, Europe)</code></li> <li><code>Some Video Game - Expansion Pack (Japan)</code></li> </ul> <p>Grouping in this way helps with 1G1R calculations, and replaces the parent/clone relationships found in LogiqX DAT files.</p>"},{"location":"collection/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>group</code> <code>string</code> <code>required</code></p> <p>The name of the group of related titles.</p> </li> <li> <p><code>titles</code> <code>object array</code> <code>required</code>.</p> <p>Contains objects that describe the details about each title that is associated with a group. Read more about the <code>titles</code> array.</p> </li> </ul>"},{"location":"collection/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>addOns</code> <code>object array</code> <code>optional</code></p> <p>The add-ons associated with titles. This includes DLC. Add-ons are at this level of the structure as they might be compatible with many variants of the <code>titles</code>. Read more about the <code>addOns</code> array.</p> </li> <li> <p><code>id</code> <code>string</code> <code>optional</code></p> <p>A globally unique ID for the group. Usually a database ID to ease lookups for DAT file maintainers. Might be referenced by a DAT application when matching compilations against individual titles using the <code>contains</code> array.</p> </li> <li> <p><code>updates</code> <code>object array</code> <code>optional</code></p> <p>The updates associated with titles. Updates are at this level of the structure as they might be compatible with many variants of the <code>titles</code>. Read more about the <code>updates</code> array.</p> </li> </ul>"},{"location":"custodianship/","title":"Custodianship","text":"<p>Making the schema publicly available and providing a stable, available pathway to updating that schema is a challenge when you consider the timescales involved might stretch to decades, given the longevity of the LogiqX DAT format.</p> <p>The following guidelines attempt to provide this stability and continuous stewardship over the schema, with full recognition that entropy and divergence are highly likely.</p>"},{"location":"custodianship/#parties-involved","title":"Parties involved","text":"<ul> <li> <p>Schema lead. A nominated figurehead. The schema lead's primary role is to    facilitate discussions and to break stalemates in voting.</p> </li> <li> <p>Git repository admins. These members manage the repository and updating of the    publicly available schema.</p> </li> <li> <p>Schema custodians. These members make decisions around changes to the schema.     Custodians are made up of long-term invested individuals, maintainers of client     software that processes DAT files, maintainers of databases that generate DAT files,     and Git repository admins.</p> </li> </ul>"},{"location":"custodianship/#schema-hosting-and-management","title":"Schema hosting and management","text":"<ol> <li> <p>The schema is hosted in a public Git repository.</p> </li> <li> <p>The repository must be managed by at least two active Git repository admins.</p> <ol> <li> <p>If an admin is inactive for more than six months, their position is considered     void and they accept that they will be replaced and their permissions removed from     the repository.</p> </li> <li> <p>A replaced admin may return to become an additional admin if they parted on good     terms with known reasons for their absence. Admins who disappear for more than     six months without notice may not return without significant justification.</p> </li> </ol> </li> <li> <p>A pull request requires at least one approval from a person who is not the author of     the pull request.</p> </li> <li> <p>Git repository admins accept the agreed-upon decisions of custodians and the schemas     they develop, regardless of personal involvement.</p> </li> </ol>"},{"location":"custodianship/#schema-proposal-process","title":"Schema proposal process","text":"<ol> <li> <p>Anyone can propose an update to the schema through a public pull request or issue, but     that proposal must come with the following:</p> <ol> <li> <p>A compelling justification.</p> </li> <li> <p>An understanding that greater weight is given to proposals made by the following:</p> <ul> <li> <p>Known larger groups who release DAT files.</p> </li> <li> <p>Maintainers of consequential client software that processes DAT files.</p> </li> </ul> </li> <li> <p>An understanding that changes impact how end clients might process a DAT file, and     that those changes might not be adopted by end clients or the groups that release     DAT files.</p> </li> <li> <p>An understanding that the proposal could be rejected.</p> </li> </ol> </li> <li> <p>The decision process to accept or reject a proposal starts when a custodian replies to     the proposal, indicating the proposal is under discussion.</p> </li> <li> <p>The discussion and voting on the decision has a time limit of 45 days.</p> </li> <li> <p>The discussion happens in public on the proposal, although deeper context might happen     in other channels. Dissenting opinions are important as a matter of record, in case     the proposal needs to be revisited in the future.</p> </li> <li> <p>The steps for the discussion should be as follows:</p> <ol> <li> <p>Ignore any proposed implementation at first. Instead, define the root issue the     proposal is trying to address.</p> </li> <li> <p>With the root issue in mind, is the proposal in scope for the schema?</p> </li> <li> <p>If the proposal is in scope, start from the angle of trying to make it work. How     do we properly solve for the root issue? What are the sensible defaults? How do we     keep optionality to a minimum?</p> </li> <li> <p>With this in mind, develop a preview schema to address the proposal.</p> </li> <li> <p>Is the impact of the preview schema on client software and database maintainers     acceptable?</p> </li> </ol> </li> <li> <p>The conduct of custodians during a discussion should be as follows:</p> <ol> <li> <p>Assume good intent from all parties involved.</p> </li> <li> <p>Make a sincere effort to understand other points of view. A useful framework for     resolving differences can be to honestly engage with the question: \"what would     have to be true to accept this?\".</p> </li> <li> <p>When in doubt, put the community needs first, not the feelings or personal     investment of the custodian, or the amount of work required to implement the     change.</p> </li> <li> <p>Refrain from heated or snide language, and refrain from personal attacks.     Don't attempt to publicly undermine other custodians.</p> </li> <li> <p>After a majority vote has been made, the issue is considered resolved, with all     parties moving forward and accepting the result.</p> </li> </ol> </li> <li> <p>A decision requires a simple majority vote to pass.</p> <ol> <li> <p>Custodians can vote to accept or reject the proposal, or abstain from the vote.</p> </li> <li> <p>A custodian who fails to vote within 45 days has their vote counted as an     abstention, regardless of circumstance.</p> </li> <li> <p>A vote stalemate is broken by the schema lead. The schema lead has up to 15 days     beyond the the initial 45 day time limit to resolve the stalemate. Upon failure to     resolve the stalemate, the proposal is rejected.</p> </li> </ol> </li> <li> <p>The decision on whether to accept or reject the proposal is posted publicly on the     proposal by a nominated custodian, with an appropriate justification. If the proposal     is accepted, an updated preview schema is provided.</p> </li> <li> <p>Upon accepting a proposal, a new schema version is submitted by custodians as a pull     request. Old schema versions remain online for compatibility with older DAT files.</p> </li> <li> <p>A new proposal that seeks to address the same root issue as a rejected proposal won't     be considered until at least 12 months after the initial rejection.</p> </li> </ol>"},{"location":"datInfo/","title":"<code>datInfo</code>","text":"<p>The <code>datInfo</code> object contains information related to the DAT file and the people who created it. It functions like a header for the file.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"datInfo\": {\n  \"schema\": \"https://www.github.com/unexpectedpanda/datmodel\",\n  \"name\": \"Company - Console\",\n  \"source\": \"Release group\",\n  \"sourceUrl\": \"https://www.example.com\",\n  \"version\": \"1.1.1\",\n  \"date\": \"2025-12-30 13:23:54\",\n  \"platformEol\": \"2013-01-04\",\n  \"contributors\": [\"Contributor 1\", \"Contributor 2\", \"Contributor 3\"],\n  \"comments\": \"Created with magic DAT generator 2.3.1\"\n}\n</code></pre> <p>ROM manager flags</p> <p>Unlike the LogiqX DAT standard, flags for specific ROM managers aren't required. Relevant metadata to implement that functionality is provided at the <code>titles</code> level.</p>"},{"location":"datInfo/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>schema</code> <code>string</code> <code>required</code></p> <p>The link back to the JSON schema that validates the DAT file.</p> </li> <li> <p><code>name</code> <code>string</code> <code>required</code></p> <p>The name of the DAT file. This is usually something that describes the scope of content covered by the file. For example, a platform (<code>Sony - PlayStation</code>), a curated collection (<code>ExoDOS</code>), a theme (<code>Adventure games</code>), or otherwise. This name is shown in client software to tell the end user what file they're working with, and to manage updates to the file.</p> </li> <li> <p><code>source</code> <code>string</code> <code>required</code></p> <p>The origin of the DAT file, whether that be a group or individual.</p> </li> <li> <p><code>date</code> <code>pattern string</code> <code>required</code></p> <p>When the DAT file was created. Must be an ISO 8601 extended format date, without the time zone (<code>YYYY-MM-DD hh:mm:ss</code>). For example: <code>2025-12-30 23:01:05</code>.</p> <ul> <li>Time uses 24-hour syntax.</li> <li>Hours, minutes, and seconds are always double digit, and use leading zeros where     appropiate.</li> <li>Seconds are optional.</li> </ul> Expand for developer details <p>Validated with the following regular expression:</p> <pre><code>^[2-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]:?){1,2}(?&lt;!:)$\n</code></pre> <p>There's a lower year bound of 2000, and an upper year bound of 9999. The regular expression also constrains month and date pairs appropriately, although it's possible to have February 29 on a non-leap year. It's assumed that systems generating the DAT file will generate valid dates to avoid this. The schema validation just enforces the format to enable easier programmatic comparisons when determining if one DAT file is newer than another.</p> </li> </ul>"},{"location":"datInfo/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>comments</code> <code>string</code> <code>optional</code></p> <p>Comments related to the DAT file. For example, compression settings used, or other things users should know about.</p> </li> <li> <p><code>contributors</code> <code>string array</code> <code>optional</code></p> <p>When multiple individuals or groups have contributed to the data contained in the DAT file, they are listed here.</p> </li> <li> <p><code>platformEol</code> <code>pattern string</code> <code>optional</code></p> <p>The end of life date for a platform that the DAT file describes. For example, the Sony Playstation 2 ceased production on 2013-01-04.</p> <p>DAT applications can use this to filter out titles that were released after the lifespan of a platform, using the <code>releaseDate</code> property.</p> </li> <li> <p><code>sourceUrl</code> <code>string</code> <code>optional</code></p> <p>The website of the source. For example, <code>https://www.example.com</code>.</p> </li> <li> <p><code>version</code> <code>pattern string</code> <code>optional</code></p> <p>The version of the DAT file. For example, <code>1.1.1</code>. The version must be a semantic version.</p> Expand for developer details <p>Validated with the following regular expression:</p> <pre><code>^(?:0|[1-9][0-9]*)\\.(?:0|[1-9][0-9]*)\\.(?:0|[1-9][0-9]*)(?:-((?:0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+(?:[0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$\n</code></pre> </li> </ul>"},{"location":"dense/","title":"Dense format","text":"<p>While JSON tends to be smaller in file size than XML due to lower character use, the data is often a lot more vertical than it is horizontal, which can at times be fatiguing for a human to browse.</p> <p>To offset this, the following example represents a more dense way of presenting the DAT file JSON. Mostly it collapses select objects to move the data horizontally.</p> <pre><code>{\n  \"datInfo\": {\n    \"schema\": \"https://www.github.com/unexpectedpanda/datmodel\",\n    \"name\": \"Company - Console\",\n    \"source\": \"Release group\",\n    \"date\": \"2025-12-30 13:30:47\"\n  },\n  \"collection\": [\n    {\n      \"group\": \"Some Video Game\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game (Japan)\",\n          \"regions\": [\"JP\"],\n          \"languages\": {\"audio\": [\"en\", \"ja\"], \"interface\": [\"ja\"], \"subtitles\": [\"en\"]},\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"files\": [\n                {\"name\" : \"file.asd\", \"size\": 123, \"digests\": {\"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"}}\n              ]\n            }\n          ]\n        },\n        {\n          \"name\": \"Some Video Game (USA)\",\n          \"regions\": [\"US\"],\n          \"languages\": {\"audio\": [\"en\"], \"interface\": [\"en\"], \"subtitles\": [\"en\"]},\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"files\": [\n                {\"name\" : \"file.asd\", \"size\": 98, \"digests\": { \"blake3\": \"d6a38bd711fbfd1065c2f7907c631590ac56249613972199a19713d7c6f10b4d\"}}\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"group\": \"Some Video Game, Other\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game, Other (USA)\",\n          \"regions\": [\"US\"],\n          \"languages\": {\"audio\": [\"en\"], \"interface\": [\"en\"], \"subtitles\": [\"en\"]},\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"files\": [\n                {\"name\" : \"file.asd\", \"size\": 456, \"digests\": {\"blake3\": \"9261749c950815ea3657f11b60c1388f5e021297c25de546001a632bdfad441d\"}}\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"dir2dat/","title":"DIR2DAT","text":""},{"location":"dir2dat/#with-groups","title":"With groups","text":"<p>You could generate a DIR2DAT with groups using the following folder structure:</p> <pre><code>\u25cf DAT root folder\n  \u251c [folder] Some Video Game // (1)!\n  \u2502   \u251c [file] Some Video Game (Japan).zip // (2)!\n  \u2502   \u2514 [file] Some Video Game (USA).zip\n  \u2514 [folder] Some Video Game, Other\n      \u2514 [file] Some Video Game, Other (USA).zip\n</code></pre> <ol> <li>Top level folder names get populated as the <code>group</code>.</li> <li>Lower levels are the titles within a group. This can be an archive of the title, or a     folder containing files.</li> </ol> <p>This would produce the following output:</p> <pre><code>{\n  \"datInfo\": {\n    \"schema\": \"https://www.github.com/unexpectedpanda/datmodel\",\n    \"name\": \"Company - Console\",\n    \"source\": \"Release group\",\n    \"date\": \"2025-12-30 13:30:47\"\n  },\n  \"collection\": [\n    {\n      \"group\": \"Some Video Game\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game (Japan)\",\n          \"regions\": [],\n          \"languages\": {\n            \"audio\": [],\n            \"interface\": [],\n            \"subtitles\": []\n          },\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"set\": [\n                {\n                  \"files\": [\n                    {\n                      \"name\" : \"file.asd\",\n                      \"size\": 123,\n                      \"digests\": {\n                        \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n                      }\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"name\": \"Some Video Game (USA)\",\n          \"regions\": [],\n          \"languages\": {\n            \"audio\": [],\n            \"interface\": [],\n            \"subtitles\": []\n          },\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"set\": [\n                {\n                  \"files\": [\n                    {\n                      \"name\" : \"file.asd\",\n                      \"size\": 98,\n                      \"digests\": {\n                        \"blake3\": \"d6a38bd711fbfd1065c2f7907c631590ac56249613972199a19713d7c6f10b4d\"\n                      }\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    },\n    {\n      \"group\": \"Some Video Game, Other\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game, Other (USA)\",\n          \"regions\": [],\n          \"languages\": {\n            \"audio\": [],\n            \"interface\": [],\n            \"subtitles\": []\n          },\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"set\": [\n                {\n                  \"files\": [\n                    {\n                      \"name\" : \"file.asd\",\n                      \"size\": 456,\n                      \"digests\": {\n                        \"blake3\": \"9261749c950815ea3657f11b60c1388f5e021297c25de546001a632bdfad441d\"\n                      }\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"dir2dat/#without-groups","title":"Without groups","text":"<p>Alternatively, you could pass a <code>--nogroups</code> flag to a DIR2DAT program, and use the following folder structure to not use groups at all:</p> <pre><code>\u25cf DAT root folder\n  \u251c Some Video Game (Japan).zip // (1)!\n  \u251c Some Video Game (USA).zip\n  \u2514 Some Video Game, Other (USA).zip\n</code></pre> <ol> <li>This can be an archive of the title, or a folder containing files.</li> </ol> <p>This results in the following DAT file:</p> <pre><code>{\n  \"datInfo\": {\n    \"schema\": \"https://www.github.com/unexpectedpanda/datmodel\",\n    \"name\": \"Company - Console\",\n    \"source\": \"Release group\",\n    \"date\": \"2025-12-30 13:30:47\"\n  },\n  \"collection\": [\n    {\n      \"group\": \"dir2dat\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game (Japan)\",\n          \"regions\": [],\n          \"languages\": {\n            \"audio\": [],\n            \"interface\": [],\n            \"subtitles\": []\n          },\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"files\": [\n                {\n                  \"name\" : \"file.asd\",\n                  \"size\": 123,\n                  \"digests\": {\n                    \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n                  }\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"name\": \"Some Video Game (USA)\",\n          \"regions\": [],\n          \"languages\": {\n            \"audio\": [],\n            \"interface\": [],\n            \"subtitles\": []\n          },\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"files\": [\n                {\n                  \"name\" : \"file.asd\",\n                  \"size\": 98,\n                  \"digests\": {\n                    \"blake3\": \"d6a38bd711fbfd1065c2f7907c631590ac56249613972199a19713d7c6f10b4d\"\n                  }\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"name\": \"Some Video Game, Other (USA)\",\n          \"regions\": [],\n          \"languages\": {\n            \"audio\": [],\n            \"interface\": [],\n            \"subtitles\": []\n          },\n          \"type\": \"Game\",\n          \"sets\": [\n            {\n              \"files\": [\n                {\n                  \"name\" : \"file.asd\",\n                  \"size\": 456,\n                  \"digests\": {\n                    \"blake3\": \"9261749c950815ea3657f11b60c1388f5e021297c25de546001a632bdfad441d\"\n                  }\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"file-format/","title":"File formats and extensions","text":""},{"location":"file-format/#file-format","title":"File format","text":"<p>The new datafile format uses JSON. This is to be paired with a publicly available JSON schema.</p>"},{"location":"file-format/#unsuitable-formats","title":"Unsuitable formats","text":"<ul> <li> <p>JSONC and JSON5 offer useful extensions to the format (such as comments, trailing   commas, and unquoted keys). However, standard JSON's ubiquity, speed, and availability   of libraries is too hard to ignore.</p> </li> <li> <p>XML is capable, however, to mimic data structures like arrays and objects is incredibly   verbose in terms of syntax, adding to file size. Although machines are doing almost all   of the work here, JSON is arguably more human-readable.</p> </li> <li> <p>YAML becomes needlessly complex with large data structures, and is a   pain to parse.</p> </li> <li> <p>TOML gets unwieldy with deeply nested data.</p> </li> </ul>"},{"location":"file-format/#file-extension","title":"File extension","text":"<p>ROM managers already have to deal with multiple formats that use the extension <code>.dat</code>, and the nomenclature of \"DATs\" or \"DAT files\" is widespread. The file extension remains <code>.dat</code> for the new model.</p>"},{"location":"files-addOns/","title":"<code>files</code>","text":"<p>The <code>files</code> array contains objects that describe the files in a file set.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"files\": [\n  {\n    \"name\": \"Some Video Game (USA) (Track 1).bin\",\n    \"size\": 10000,\n    \"digests\": {\n      \"crc32\": \"29edd0e3\",\n      \"xxh3_128\": \"1a2bf3bb0a4cd3aa94bf08b1c269423e\",\n      \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Track 2).bin\",\n    \"size\": 1000,\n    \"digests\": {\n      \"crc32\": \"872f5343\",\n      \"xxh3_128\": \"b993a0619f896a101e786850967b3d90\",\n      \"blake3\": \"74277af46089c2b15aea5b193bdecdd58a2992e47b00956c678a6c070225cb18\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA).cue\",\n    \"size\": 100,\n    \"digests\": {\n      \"crc32\": \"987150b7\",\n      \"xxh3_128\": \"b7bb3254808cfc06d899854a1b58bab0\",\n      \"blake3\": \"fcbc02c56a9a5157255febeac2009a988ccd08863ff648d290fe973dffe7f88c\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  }\n]\n</code></pre>"},{"location":"files-addOns/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the file, in UTF-8. Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\\\\\|?*].*[^. :&lt;&gt;\\\"\\\\\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>size</code> <code>int</code> <code>required</code></p> <p>The size of the file, in bytes.</p> </li> <li> <p><code>digests</code> <code>object</code> <code>required</code></p> <p>The digests of different hash functions. The object must contain at least one digest. The following hash functions are preferred:</p> <ul> <li> <p><code>crc32</code> (pattern string): Don't use for verifying untrusted files (not even when   combined with file size, see the developer details). However, CRC32 is still useful,   as many container formats like ZIP make the CRC32 of their internal files accessible   without them needing to be extracted. Because of this, CRC32 can be used for initial   validation that a file inside an archive is worth extracting. The extracted file   should then be tested with a more reliable hashing function to verify that it's   the correct file.</p> Expand for developer details <p>Valid CRC32 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{8,8}$\n</code></pre> <p>Don't fall into the trap of thinking CRC32 + file size is enough to verify a file is the correct one. Here are four different files from the one archive, <code>segasp.zip</code>, in MAME:</p> <pre><code>\"name\": \"fpr-24208a.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"81abd9705b6ae17bd232b9fe96f12de8\",\n  \"sha1\": \"3c32ddfb3c40be66b9fb2ba35fbfd5b534bb3da0\",\n  \"sha256\": \"db9470c83a4b17cc7441b6fe6d824a1a6e299964a4a79bf8e5e6229fd542c120\",\n  \"xxh3_128\": \"8c65f0bc5c3889a0f10d59de5125db4b\",\n  \"blake3\": \"a850810cc35294c32c970870495d8f63a1328b8ea4d0c0ddef5c56daf76255c0\"\n},\n\"name\": \"fpr-24329.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"7cf5e46dd564d3a88b4f7e24a1d57362\",\n  \"sha1\": \"d0d062a4089a2d3404df45eb015faaf7eee9b8c2\",\n  \"sha256\": \"85af02e76cde08f8ed4e02c7736af7c920157dbb7e7c5cf10606d457ae97b71c\",\n  \"xxh3_128\": \"5b8d6afb1cc5d965bad5d626c760174c\",\n  \"blake3\": \"109d5884b004dd828cf2f65be422ab75464a85847c92f74f43f3812e59fee340\"\n},\n\"name\": \"fpr-24407.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"ec790069699b0312d3e374b17d1b7e20\",\n  \"sha1\": \"fbcc3d119b47a6da4d194e3fe4a98126c7049edf\",\n  \"sha256\": \"8fb1dadbc7e2a599cbcf30338c3a6e97ef24955cc0f2ceae781169ad8223cb59\",\n  \"xxh3_128\": \"45bb3c0d4298a2472e94031d88318286\",\n  \"blake3\": \"260827d650c68f62eccf207528f6f88bfa1be0088983ea1897bb3ac02c7883f0\"\n},\n\"name\": \"fpr-24407_123.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"369b9634d187fd5cd28f09397a99359a\",\n  \"sha1\": \"3f5a2fb03bbb1bd9af9fe32ad76a224c97aa9b7a\",\n  \"sha256\": \"1979ae53d47e6bb52448623fb772d86ef997d8514b11955c41de6a09ee1913cb\",\n  \"xxh3_128\": \"dae252a24f23999208cd945aded75f11\",\n  \"blake3\": \"699a9cb452239bc4d678664a78351bb90a1a007a71c2a6974a77e09db2da5446\"\n}\n</code></pre> </li> <li> <p><code>sha256</code> (pattern string): Can be used for verifying untrusted files. SHA256   should only be used by client applications if the user's processor supports hardware   acceleration of the hashing function, or if no other digests are supplied for   verifying untrusted files.</p> Expand for developer details <p>Valid SHA256 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> <li> <p><code>xxh3_128</code> (pattern string): Can be used for checksumming trusted files.</p> Expand for developer details <p>Valid XXH3 128 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>blake3</code> (pattern string): Can be used for verifying untrusted files.</p> Expand for developer details <p>Valid BLAKE3 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> </ul> <p>The following hash functions should only be used in specific circumstances:</p> <ul> <li> <p><code>md5</code> (pattern string): Legacy hashing function. Wherever possible, don't use   this. The only permissable situation is if you're converting old DAT files that   don't contain more reliable hashes, and don't possess the files yourself to rehash   them with something better. Otherwise, replace with prejudice.</p> Expand for developer details <p>Valid MD5 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>sha1</code> (pattern string): Can be used for verifying untrusted files, but prefer   SHA256 or BLAKE3 where possible. SHA1 should only be used by client applications if   the user's processor supports hardware acceleration of the hashing function, or if   no other digests are supplied for verifying untrusted files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> <li> <p><code>sha1Internal</code> (pattern string): The internal SHA-1 used only for CHD files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> </ul> </li> </ul>"},{"location":"files-addOns/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>dateModified</code> <code>pattern string</code> <code>optional</code></p> <p>The last modified date that should be applied by the DAT application to the file.</p> <p>Only useful for old DOS titles that used timestamps as part of their copy protection.</p> <p>The date format is as follows:</p> <pre><code>YYYY-MM-DD hh:mm:ss\n</code></pre> <p>Because FAT file systems have a time resolution of 2 seconds on last modified dates, you can only use even numbers for the seconds. For example:</p> <pre><code>1980-01-01 12:35:56\n1991-12-30 23:13:32\n1992-11-24 03:12:00\n</code></pre> <p>Files with specified <code>dateModified</code> fields must not be stored in archives that change or remove the timestamp.</p> Expand for developer details <p>You can find a valid last modified timestamp with the following regular expression:</p> <pre><code>^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]):(?:[0-5][02468])(?&lt;!:)$\n</code></pre> </li> <li> <p><code>header</code> <code>string</code> <code>optional</code></p> <p>The header for a file, in hex. Aids with addition of a header to a headerless file, or removal from a headered file.</p> </li> </ul>"},{"location":"files-set/","title":"<code>files</code>","text":"<p>The <code>files</code> array contains objects that describe the files in a file set.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"files\": [\n  {\n    \"name\": \"Some Video Game (USA) (Track 1).bin\",\n    \"size\": 10000,\n    \"digests\": {\n      \"crc32\": \"29edd0e3\",\n      \"xxh3_128\": \"1a2bf3bb0a4cd3aa94bf08b1c269423e\",\n      \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Track 2).bin\",\n    \"size\": 1000,\n    \"digests\": {\n      \"crc32\": \"872f5343\",\n      \"xxh3_128\": \"b993a0619f896a101e786850967b3d90\",\n      \"blake3\": \"74277af46089c2b15aea5b193bdecdd58a2992e47b00956c678a6c070225cb18\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA).cue\",\n    \"size\": 100,\n    \"digests\": {\n      \"crc32\": \"987150b7\",\n      \"xxh3_128\": \"b7bb3254808cfc06d899854a1b58bab0\",\n      \"blake3\": \"fcbc02c56a9a5157255febeac2009a988ccd08863ff648d290fe973dffe7f88c\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  }\n]\n</code></pre>"},{"location":"files-set/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the file, in UTF-8. Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\\\\\|?*].*[^. :&lt;&gt;\\\"\\\\\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>size</code> <code>int</code> <code>required</code></p> <p>The size of the file, in bytes.</p> </li> <li> <p><code>digests</code> <code>object</code> <code>required</code></p> <p>The digests of different hash functions. The object must contain at least one digest. The following hash functions are preferred:</p> <ul> <li> <p><code>crc32</code> (pattern string): Don't use for verifying untrusted files (not even when   combined with file size, see the developer details). However, CRC32 is still useful,   as many container formats like ZIP make the CRC32 of their internal files accessible   without them needing to be extracted. Because of this, CRC32 can be used for initial   validation that a file inside an archive is worth extracting. The extracted file   should then be tested with a more reliable hashing function to verify that it's   the correct file.</p> Expand for developer details <p>Valid CRC32 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{8,8}$\n</code></pre> <p>Don't fall into the trap of thinking CRC32 + file size is enough to verify a file is the correct one. Here are four different files from the one archive, <code>segasp.zip</code>, in MAME:</p> <pre><code>\"name\": \"fpr-24208a.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"81abd9705b6ae17bd232b9fe96f12de8\",\n  \"sha1\": \"3c32ddfb3c40be66b9fb2ba35fbfd5b534bb3da0\",\n  \"sha256\": \"db9470c83a4b17cc7441b6fe6d824a1a6e299964a4a79bf8e5e6229fd542c120\",\n  \"xxh3_128\": \"8c65f0bc5c3889a0f10d59de5125db4b\",\n  \"blake3\": \"a850810cc35294c32c970870495d8f63a1328b8ea4d0c0ddef5c56daf76255c0\"\n},\n\"name\": \"fpr-24329.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"7cf5e46dd564d3a88b4f7e24a1d57362\",\n  \"sha1\": \"d0d062a4089a2d3404df45eb015faaf7eee9b8c2\",\n  \"sha256\": \"85af02e76cde08f8ed4e02c7736af7c920157dbb7e7c5cf10606d457ae97b71c\",\n  \"xxh3_128\": \"5b8d6afb1cc5d965bad5d626c760174c\",\n  \"blake3\": \"109d5884b004dd828cf2f65be422ab75464a85847c92f74f43f3812e59fee340\"\n},\n\"name\": \"fpr-24407.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"ec790069699b0312d3e374b17d1b7e20\",\n  \"sha1\": \"fbcc3d119b47a6da4d194e3fe4a98126c7049edf\",\n  \"sha256\": \"8fb1dadbc7e2a599cbcf30338c3a6e97ef24955cc0f2ceae781169ad8223cb59\",\n  \"xxh3_128\": \"45bb3c0d4298a2472e94031d88318286\",\n  \"blake3\": \"260827d650c68f62eccf207528f6f88bfa1be0088983ea1897bb3ac02c7883f0\"\n},\n\"name\": \"fpr-24407_123.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"369b9634d187fd5cd28f09397a99359a\",\n  \"sha1\": \"3f5a2fb03bbb1bd9af9fe32ad76a224c97aa9b7a\",\n  \"sha256\": \"1979ae53d47e6bb52448623fb772d86ef997d8514b11955c41de6a09ee1913cb\",\n  \"xxh3_128\": \"dae252a24f23999208cd945aded75f11\",\n  \"blake3\": \"699a9cb452239bc4d678664a78351bb90a1a007a71c2a6974a77e09db2da5446\"\n}\n</code></pre> </li> <li> <p><code>sha256</code> (pattern string): Can be used for verifying untrusted files. SHA256   should only be used by client applications if the user's processor supports hardware   acceleration of the hashing function, or if no other digests are supplied for   verifying untrusted files.</p> Expand for developer details <p>Valid SHA256 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> <li> <p><code>xxh3_128</code> (pattern string): Can be used for checksumming trusted files.</p> Expand for developer details <p>Valid XXH3 128 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>blake3</code> (pattern string): Can be used for verifying untrusted files.</p> Expand for developer details <p>Valid BLAKE3 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> </ul> <p>The following hash functions should only be used in specific circumstances:</p> <ul> <li> <p><code>md5</code> (pattern string): Legacy hashing function. Wherever possible, don't use   this. The only permissable situation is if you're converting old DAT files that   don't contain more reliable hashes, and don't possess the files yourself to rehash   them with something better. Otherwise, replace with prejudice.</p> Expand for developer details <p>Valid MD5 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>sha1</code> (pattern string): Can be used for verifying untrusted files, but prefer   SHA256 or BLAKE3 where possible. SHA1 should only be used by client applications if   the user's processor supports hardware acceleration of the hashing function, or if   no other digests are supplied for verifying untrusted files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> <li> <p><code>sha1Internal</code> (pattern string): The internal SHA-1 used only for CHD files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> </ul> </li> </ul>"},{"location":"files-set/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>dateModified</code> <code>pattern string</code> <code>optional</code></p> <p>The last modified date that should be applied by the DAT application to the file.</p> <p>Only useful for old DOS titles that used timestamps as part of their copy protection.</p> <p>The date format is as follows:</p> <pre><code>YYYY-MM-DD hh:mm:ss\n</code></pre> <p>Because FAT file systems have a time resolution of 2 seconds on last modified dates, you can only use even numbers for the seconds. For example:</p> <pre><code>1980-01-01 12:35:56\n1991-12-30 23:13:32\n1992-11-24 03:12:00\n</code></pre> <p>Files with specified <code>dateModified</code> fields must not be stored in archives that change or remove the timestamp.</p> Expand for developer details <p>You can find a valid last modified timestamp with the following regular expression:</p> <pre><code>^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]):(?:[0-5][02468])(?&lt;!:)$\n</code></pre> </li> <li> <p><code>header</code> <code>string</code> <code>optional</code></p> <p>The header for a file, in hex. Aids with addition of a header to a headerless file, or removal from a headered file.</p> </li> </ul>"},{"location":"files-updates/","title":"<code>files</code>","text":"<p>The <code>files</code> array contains objects that describe the files in a file set.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"files\": [\n  {\n    \"name\": \"Some Video Game (USA) (Track 1).bin\",\n    \"size\": 10000,\n    \"digests\": {\n      \"crc32\": \"29edd0e3\",\n      \"xxh3_128\": \"1a2bf3bb0a4cd3aa94bf08b1c269423e\",\n      \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Track 2).bin\",\n    \"size\": 1000,\n    \"digests\": {\n      \"crc32\": \"872f5343\",\n      \"xxh3_128\": \"b993a0619f896a101e786850967b3d90\",\n      \"blake3\": \"74277af46089c2b15aea5b193bdecdd58a2992e47b00956c678a6c070225cb18\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA).cue\",\n    \"size\": 100,\n    \"digests\": {\n      \"crc32\": \"987150b7\",\n      \"xxh3_128\": \"b7bb3254808cfc06d899854a1b58bab0\",\n      \"blake3\": \"fcbc02c56a9a5157255febeac2009a988ccd08863ff648d290fe973dffe7f88c\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  }\n]\n</code></pre>"},{"location":"files-updates/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the file, in UTF-8. Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\\\\\|?*].*[^. :&lt;&gt;\\\"\\\\\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>size</code> <code>int</code> <code>required</code></p> <p>The size of the file, in bytes.</p> </li> <li> <p><code>digests</code> <code>object</code> <code>required</code></p> <p>The digests of different hash functions. The object must contain at least one digest. The following hash functions are preferred:</p> <ul> <li> <p><code>crc32</code> (pattern string): Don't use for verifying untrusted files (not even when   combined with file size, see the developer details). However, CRC32 is still useful,   as many container formats like ZIP make the CRC32 of their internal files accessible   without them needing to be extracted. Because of this, CRC32 can be used for initial   validation that a file inside an archive is worth extracting. The extracted file   should then be tested with a more reliable hashing function to verify that it's   the correct file.</p> Expand for developer details <p>Valid CRC32 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{8,8}$\n</code></pre> <p>Don't fall into the trap of thinking CRC32 + file size is enough to verify a file is the correct one. Here are four different files from the one archive, <code>segasp.zip</code>, in MAME:</p> <pre><code>\"name\": \"fpr-24208a.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"81abd9705b6ae17bd232b9fe96f12de8\",\n  \"sha1\": \"3c32ddfb3c40be66b9fb2ba35fbfd5b534bb3da0\",\n  \"sha256\": \"db9470c83a4b17cc7441b6fe6d824a1a6e299964a4a79bf8e5e6229fd542c120\",\n  \"xxh3_128\": \"8c65f0bc5c3889a0f10d59de5125db4b\",\n  \"blake3\": \"a850810cc35294c32c970870495d8f63a1328b8ea4d0c0ddef5c56daf76255c0\"\n},\n\"name\": \"fpr-24329.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"7cf5e46dd564d3a88b4f7e24a1d57362\",\n  \"sha1\": \"d0d062a4089a2d3404df45eb015faaf7eee9b8c2\",\n  \"sha256\": \"85af02e76cde08f8ed4e02c7736af7c920157dbb7e7c5cf10606d457ae97b71c\",\n  \"xxh3_128\": \"5b8d6afb1cc5d965bad5d626c760174c\",\n  \"blake3\": \"109d5884b004dd828cf2f65be422ab75464a85847c92f74f43f3812e59fee340\"\n},\n\"name\": \"fpr-24407.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"ec790069699b0312d3e374b17d1b7e20\",\n  \"sha1\": \"fbcc3d119b47a6da4d194e3fe4a98126c7049edf\",\n  \"sha256\": \"8fb1dadbc7e2a599cbcf30338c3a6e97ef24955cc0f2ceae781169ad8223cb59\",\n  \"xxh3_128\": \"45bb3c0d4298a2472e94031d88318286\",\n  \"blake3\": \"260827d650c68f62eccf207528f6f88bfa1be0088983ea1897bb3ac02c7883f0\"\n},\n\"name\": \"fpr-24407_123.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"369b9634d187fd5cd28f09397a99359a\",\n  \"sha1\": \"3f5a2fb03bbb1bd9af9fe32ad76a224c97aa9b7a\",\n  \"sha256\": \"1979ae53d47e6bb52448623fb772d86ef997d8514b11955c41de6a09ee1913cb\",\n  \"xxh3_128\": \"dae252a24f23999208cd945aded75f11\",\n  \"blake3\": \"699a9cb452239bc4d678664a78351bb90a1a007a71c2a6974a77e09db2da5446\"\n}\n</code></pre> </li> <li> <p><code>sha256</code> (pattern string): Can be used for verifying untrusted files. SHA256   should only be used by client applications if the user's processor supports hardware   acceleration of the hashing function, or if no other digests are supplied for   verifying untrusted files.</p> Expand for developer details <p>Valid SHA256 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> <li> <p><code>xxh3_128</code> (pattern string): Can be used for checksumming trusted files.</p> Expand for developer details <p>Valid XXH3 128 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>blake3</code> (pattern string): Can be used for verifying untrusted files.</p> Expand for developer details <p>Valid BLAKE3 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> </ul> <p>The following hash functions should only be used in specific circumstances:</p> <ul> <li> <p><code>md5</code> (pattern string): Legacy hashing function. Wherever possible, don't use   this. The only permissable situation is if you're converting old DAT files that   don't contain more reliable hashes, and don't possess the files yourself to rehash   them with something better. Otherwise, replace with prejudice.</p> Expand for developer details <p>Valid MD5 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>sha1</code> (pattern string): Can be used for verifying untrusted files, but prefer   SHA256 or BLAKE3 where possible. SHA1 should only be used by client applications if   the user's processor supports hardware acceleration of the hashing function, or if   no other digests are supplied for verifying untrusted files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> <li> <p><code>sha1Internal</code> (pattern string): The internal SHA-1 used only for CHD files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> </ul> </li> </ul>"},{"location":"files-updates/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>dateModified</code> <code>pattern string</code> <code>optional</code></p> <p>The last modified date that should be applied by the DAT application to the file.</p> <p>Only useful for old DOS titles that used timestamps as part of their copy protection.</p> <p>The date format is as follows:</p> <pre><code>YYYY-MM-DD hh:mm:ss\n</code></pre> <p>Because FAT file systems have a time resolution of 2 seconds on last modified dates, you can only use even numbers for the seconds. For example:</p> <pre><code>1980-01-01 12:35:56\n1991-12-30 23:13:32\n1992-11-24 03:12:00\n</code></pre> <p>Files with specified <code>dateModified</code> fields must not be stored in archives that change or remove the timestamp.</p> Expand for developer details <p>You can find a valid last modified timestamp with the following regular expression:</p> <pre><code>^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]):(?:[0-5][02468])(?&lt;!:)$\n</code></pre> </li> <li> <p><code>header</code> <code>string</code> <code>optional</code></p> <p>The header for a file, in hex. Aids with addition of a header to a headerless file, or removal from a headered file.</p> </li> </ul>"},{"location":"fileset/","title":"<code>fileset</code>","text":"<p>The <code>fileset</code> array is a way to bundle together multiple groups of files and their properties. For example, you might want to bundle multiple discs from a single title together, so DAT applications know to keep those files together when filtering.</p> <pre><code>\"fileset\": [\n  {\n    \"name\": \"Some Video Game (USA) (Disc 1)\",\n    \"container\": \"auto\",\n    \"id\": \"654319\",\n    \"comments\": \"Something relevant about the set\",\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Disc 2)\",\n    \"container\": \"auto\",\n    \"id\": \"654320\",\n    \"comments\": \"Something relevant about the set\",\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"refId\": \"123456\"\n  }\n]\n</code></pre>"},{"location":"fileset/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>files</code> <code>object array</code> <code>required</code></p> <p>The files in the set and their properties. Read more about the <code>files</code> array.</p> </li> <li> <p><code>name</code> <code>pattern string</code> <code>condtionally required</code></p> <p>Overrides the title <code>name</code> key to become the archive or folder name used for the set.</p> <p>Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> <p>Condition: Required when the <code>container</code> property isn't set to <code>null</code>. Optional when it is.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\|?*].*[^. :&lt;&gt;\\\"\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> </ul>"},{"location":"fileset/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>comments</code> <code>string</code> <code>optional</code></p> <p>Comments related to the fileset.</p> </li> <li> <p><code>container</code> <code>string</code> <code>optional</code></p> <p>The container that the DAT application should use for the file set. Must be one of the following values:</p> <ul> <li> <p><code>auto</code>: Store the files in whatever container the user chooses in the DAT   application. For example, a ZIP file, a 7Z file, a folder, or no container. The base   file name of the container matches the <code>name</code>.</p> </li> <li> <p><code>folder</code>: Store the files in a folder named after the   <code>name</code>.</p> </li> <li> <p><code>null</code>: Don't store the files in any container. Useful for keeping files by   themselves, or for treating archives as files.</p> </li> </ul> <p>If this property isn't present, the DAT application assumes the value is <code>auto</code>. Unless the <code>container</code> is set to <code>null</code>, you must supply a <code>name</code>.</p> </li> <li> <p><code>id</code> <code>string</code> <code>optional</code></p> <p>A globally unique ID for the fileset item. Usually a database ID to ease lookups for DAT file maintainers.</p> </li> </ul>"},{"location":"goals/","title":"Goals, non-goals, and risks","text":""},{"location":"goals/#goals","title":"Goals","text":"<ul> <li> <p>A data format that provides additional metadata for enhanced functionality in the client   software that processes it. This functionality includes:</p> <ul> <li> <p>Improved filtering and 1G1R processing, without requiring the inference done by   applications like Retool to match and   rank titles.</p> </li> <li> <p>Grouping multiple discs together that belong to the same title, so that filtering   doesn't break sets apart.</p> </li> <li> <p>Grouping updates and addons (including DLC) with the titles they can be validly   applied to.</p> </li> </ul> </li> <li> <p>A shift away from ROM nomenclature towards general file management language.</p> </li> <li> <p>Improvements in data validation, which take into account the following:</p> <ul> <li> <p>More rigid enforcement of standards, to make data comparison easier.</p> </li> <li> <p>Updates to standards due to world and technology changes, and a need for higher   accuracy.</p> </li> </ul> </li> <li> <p>A completed schema published in a public repository, alongside an updated version of   this documentation to account for changes during the development process.</p> </li> </ul>"},{"location":"goals/#non-goals","title":"Non-goals","text":"<ul> <li> <p>This proposal doesn't cover MAME, which continues to run its own race.</p> </li> <li> <p>Genres aren't covered, as too often they aren't agreed upon. Additionally, adding   multiple genres to a title makes filtering by genre less meaningful.</p> </li> <li> <p>This proposal doesn't seek to alter file naming standards put in place by DAT groups.   However, its validation might be looser or more restrictive than a given naming standard   depending on the particular field. For example, the ancient No-Intro   guidelines   insist on 7\u2011bit ASCII in file names, while this DAT schema allows for the now   ubiquitous UTF\u20118.</p> </li> <li> <p>Metadata that can't be used to manage or filter files, for example primary volume   descriptors, isn't included in the standard. Managing this sort of metadata is up to the   individuals or groups that release DAT files to store and distribute how they choose.</p> </li> <li> <p>It's tempting to define a standard that can enable client software to handle complex   nested containers, and container conversion. For example:</p> <ul> <li> <p>Build a RAR archive from constituent files, then place that RAR inside a ZIP   archive, and then along with other files and predefined partitions build everything   into the final ISO file.</p> </li> <li> <p>Convert an ISO file to CHD and vice versa.</p> </li> </ul> <p>This capability is particularly appealing to those who seek to maximise available disk space, minimize file duplication, and enable virtual file systems that can transparently construct final containers when required.</p> <p>However, image file formats often have origin-specific configurations despite identical file extensions, compressed containers can be non-deterministic, and even deterministic containers can change their output between version and setting changes. There's also a dearth of cross-language libraries available for developers to integrate into their own DAT management software, whether that be parsing or creating DAT files.</p> <p>This functionality is therefore considered out of scope, and is more appropriately left to an external party who reverse-engineers the extraction of containers listed in a DAT file into their own, more detailed DAT files.</p> </li> </ul>"},{"location":"goals/#risks","title":"Risks","text":"<ul> <li> <p>The complexity of the new format requires significant work in terms of the following:</p> <ul> <li> <p>Building appropriate interfaces to input data, paired with appropriate validation to   ensure the output matches the schema.</p> </li> <li> <p>Redesigning tables and entity relationships in databases.</p> </li> <li> <p>Writing code to generate, parse, and make use of the data in the DAT files.</p> </li> </ul> <p>Due to the organic nature of how the LogiqX standard arose over time, and the work that's involved in starting fresh, it's likely that inertia in retaining the old format will be difficult to overcome.</p> </li> </ul>"},{"location":"reference/","title":"Reference other file sets","text":"<p>Sometimes there are file sets that are shared between titles. For example, you might have the following set of discs that make up the USA variant of a title:</p> <ul> <li><code>Some Video Game (USA) (Disc 1)</code></li> <li><code>Some Video Game (USA, Europe) (Disc 2)</code></li> </ul> <p>And the following set of discs that make up the Europe variant of a title:</p> <ul> <li><code>Some Video Game (Europe) (Disc 1)</code></li> <li><code>Some Video Game (USA, Europe) (Disc 2)</code></li> </ul> <p>Where <code>Some Video Game (USA, Europe) (Disc 2)</code> is identical between the two variants.</p> <p>Instead of listing both entries, you can list the USA variant as the source, and then reference it inside the Europe variant. A DAT application can then treat the referenced file set differently to the source to save disk space, depending on the situation and user preference.</p> <p>The following example shows creating a reference using the <code>refId</code> property. The parts of the code that represent the reference are highlighted.</p> <pre><code>{\n  \"datInfo\": {\n    \"schema\": \"https://www.github.com/unexpectedpanda/datmodel\",\n    \"name\": \"Reference ID example\",\n    \"source\": \"Data model 2025\",\n    \"date\": \"2025-12-30 13:23:54\"\n  },\n  \"collection\": [\n    {\n      \"group\": \"Some Video Game\",\n      \"titles\": [\n        {\n          \"name\": \"Some Video Game (Europe)\",\n          \"regions\": [\"EUR\"],\n          \"languages\": {\n            \"audio\": [null],\n            \"interface\": [\"en\"],\n            \"subtitles\": [null]\n          },\n          \"sets\": [\n            {\n              \"fileset\": [\n                {\n                  \"name\": \"Some Video Game (Europe) (Disc 1)\",\n                  \"id\": \"123458\",\n                  \"files\": [\n                    {\n                      \"name\": \"Some Video Game (Europe) (Disc 1).iso\",\n                      \"size\": 10000,\n                      \"digests\": {\n                        \"crc32\": \"29edd0e3\",\n                        \"xxh3_128\": \"1a2bf3bb0a4cd3aa94bf08b1c269423e\",\n                        \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n                      }\n                    }\n                  ]\n                },\n                {\n                  \"refId\": \"123457\"\n                }\n              ]\n            }\n          ]\n        },\n        {\n          \"name\": \"Some Video Game (USA)\",\n          \"regions\": [\"US\"],\n          \"languages\": {\n            \"audio\": [null],\n            \"interface\": [\"en\"],\n            \"subtitles\": [null]\n          },\n          \"sets\": [\n            {\n              \"fileset\": [\n                {\n                  \"name\": \"Some Video Game (USA) (Disc 1)\",\n                  \"id\": \"123456\",\n                  \"files\": [\n                    {\n                      \"name\": \"Some Video Game (USA) (Disc 1).iso\",\n                      \"size\": 10000,\n                      \"digests\": {\n                        \"crc32\": \"29edd0e3\",\n                        \"xxh3_128\": \"1a2bf3bb0a4cd3aa94bf08b1c269423e\",\n                        \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n                      }\n                    }\n                  ]\n                },\n                {\n                  \"name\": \"Some Video Game (USA, Europe) (Disc 2)\",\n                  \"id\": \"123457\",\n                  \"files\": [\n                    {\n                      \"name\": \"Some Video Game (USA, Europe) (Disc 2).iso\",\n                      \"size\": 10000,\n                      \"digests\": {\n                        \"crc32\": \"150cc86c\",\n                        \"xxh3_128\": \"562ab7b9c5d8c3697d0b7641f389e946\",\n                        \"blake3\": \"aa70c31c05bd6a4c5200599b2ee211005f5ce5fe67a3d1ac14e1f7f02bb8553a\"\n                      }\n                    }\n                  ]\n                }\n              ]\n            }\n          ]\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <p>In the previous example, a DAT application sees the <code>refId</code> to the unique global identifier <code>123457</code>. It then scours the DAT file at the <code>sets</code> and <code>fileset</code> level for a matching <code>id</code>, and imports any properties that aren't defined locally \u2014 in this case <code>name</code>, <code>files</code>, and all the <code>files</code> subproperties. The <code>id</code> property is not imported.</p> <p>Therefore the following code sample:</p> <pre><code>{\n  \"refId\": \"123457\"\n}\n</code></pre> <p>Is effectively interpreted as follows:</p> <pre><code>{\n  \"refId\": \"123457\",\n  \"name\": \"Some Video Game (USA, Europe) (Disc 2)\",\n  \"files\": [\n    {\n      \"name\": \"Some Video Game (USA, Europe) (Disc 2).iso\",\n      \"size\": 10000,\n      \"digests\": {\n        \"crc32\": \"150cc86c\",\n        \"xxh3_128\": \"562ab7b9c5d8c3697d0b7641f389e946\",\n        \"blake3\": \"aa70c31c05bd6a4c5200599b2ee211005f5ce5fe67a3d1ac14e1f7f02bb8553a\"\n      }\n    }\n  ]\n}\n</code></pre> <p>Properties that are defined locally are treated as overrides, and are preferenced over imported properties. For example, the following code sample:</p> <pre><code>{\n  \"name\": \"Some Video Game (Europe) (Disc 2)\",\n  \"refId\": \"123457\"\n}\n</code></pre> <p>Is effectively interpreted as follows:</p> <pre><code>{\n  \"refId\": \"123457\",\n  \"name\": \"Some Video Game (Europe) (Disc 2)\",\n  \"files\": [\n    {\n      \"name\": \"Some Video Game (USA, Europe) (Disc 2).iso\",\n      \"size\": 10000,\n      \"digests\": {\n        \"crc32\": \"150cc86c\",\n        \"xxh3_128\": \"562ab7b9c5d8c3697d0b7641f389e946\",\n        \"blake3\": \"aa70c31c05bd6a4c5200599b2ee211005f5ce5fe67a3d1ac14e1f7f02bb8553a\"\n      }\n    }\n  ]\n}\n</code></pre> <p>You can only reference an entire top-levl object in the <code>sets</code> or <code>fileset</code> arrays. This means you can't reference individual files, or set a local <code>name</code> for individual files.</p>"},{"location":"reference/#file-storage-behavior","title":"File storage behavior","text":"<p>A DAT application can then choose the following behavior for referenced filesets, based on situation and user preference:</p> <ul> <li> <p>If the container is stored in the same destination folder and imports the <code>name</code>   property, ignore the reference, the file is already available.</p> </li> <li> <p>If the container is stored in a different destination folder than the original, do   one of the following:</p> <ul> <li> <p>Create a symbolic link to the reference container.</p> </li> <li> <p>Create a copy of the reference container.</p> </li> </ul> </li> <li> <p>If the container sets a local <code>name</code> property, do one of the following:</p> <ul> <li> <p>Create a symbolic link to the reference container, but use the local <code>name</code>   property as the file name.</p> </li> <li> <p>Create a copy of the reference container, renaming it with the local <code>name</code>   property.</p> </li> </ul> </li> </ul> <p>The following example shows how to reference the files that are in another title. This only links to a specific <code>files</code> array, it doesn't link to individual files.</p>"},{"location":"schema/","title":"Schema","text":"<p>You can test validating against this schema with JSON Schema Validator.</p> <pre><code>{\n  \"$schema\": \"https://json-schema.org/draft/2020-12/schema\",\n  \"$id\":\"https://www.github.com/unexpectedpanda/datmodel\",\n  \"title\": \"DAT file specification\",\n  \"description\": \"2025-03-18 19:41\",\n  \"type\": \"object\",\n  \"required\": [\"datInfo\", \"collection\"],\n  \"additionalProperties\": false,\n  \"properties\": {\n    \"datInfo\": {\n      \"description\": \"Content that describes the DAT file and its origin.\",\n      \"type\": \"object\",\n      \"required\": [\"schema\", \"name\", \"source\", \"date\"],\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"comments\": {\n          \"description\": \"Comments related to the DAT file. For example, compression settings used, or other things users should know about.\",\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        \"contributors\": {\n          \"description\": \"When multiple people have contributed to the data contained in the DAT file, they are listed here.\",\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          }\n        },\n        \"date\": {\n          \"description\": \"When the DAT file was created, in extended ISO 8601 format, without the time zone. For example: YYYY-MM-DD hh:mm:ss. Seconds are optional.\",\n          \"$ref\": \"#/$defs/nonEmptyString\",\n          \"pattern\": \"^[2-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]:?){1,2}(?&lt;!:)$\"\n        },\n        \"name\": {\n          \"description\": \"The scope of content covered by the DAT file. This might be a platform, curated collection, a theme, or otherwise.\",\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        \"platformEol\": {\n          \"description\": \"The end of life date for a platform that the DAT file describes. For example, the Sony Playstation 2 ceased production on 2013-01-04. Valid formats are YYYY-MM-DD, YYYY-MM, and YYYY.\",\n          \"anyOf\": [\n            {\n              \"description\": \"YYYY-MM-DD\",\n              \"pattern\": \"^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01]))$\"\n            },\n            {\n              \"description\": \"YYYY-MM\",\n              \"pattern\": \"^[1-9][0-9]{3,3}-(?:0[1-9]|1[0-2])$\"\n            },\n            {\n              \"description\": \"YYYY\",\n              \"pattern\": \"^[1-9][0-9]{3,3}$\"\n            }\n          ]\n        },\n        \"schema\": {\n          \"description\": \"A link to the DAT schema used for the file.\",\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        \"source\": {\n          \"description\": \"The origin of the DAT file, whether that be a group or individual.\",\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        \"sourceUrl\": {\n          \"description\": \"The website of the source.\",\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        \"version\": {\n          \"description\": \"The version of the DAT file, following semantic versioning.\",\n          \"$ref\": \"#/$defs/nonEmptyString\",\n          \"pattern\": \"^(?:0|[1-9][0-9]*)\\\\.(?:0|[1-9][0-9]*)\\\\.(?:0|[1-9][0-9]*)(?:-((?:0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\\\.(?:0|[1-9][0-9]*|[0-9]*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\\\+(?:[0-9a-zA-Z-]+(?:\\\\.[0-9a-zA-Z-]+)*))?$\"\n        }\n      }\n    },\n    \"collection\": {\n      \"description\": \"Content that describes titles in the collection.\",\n      \"type\": \"array\",\n      \"minProperties\": 1,\n      \"contains\": {\n        \"type\": \"object\",\n        \"required\": [\"group\", \"titles\"],\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"addOns\": {\n            \"description\": \"The add-ons associated with the set. This includes DLC.\",\n            \"type\": \"array\",\n            \"contains\": {\n              \"type\": \"object\",\n              \"required\": [\"name\", \"files\"],\n              \"additionalProperties\": false,\n              \"properties\": {\n                \"comments\": {\n                  \"description\": \"Commented related to the add-on.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"container\": {\n                  \"description\": \"The container that the DAT application should use for the file set. Must be one of the following values: auto, folder, or null.\",\n                  \"$ref\": \"#/$defs/container\"\n                },\n                \"files\": {\n                  \"$ref\": \"#/$defs/files\"\n                },\n                \"id\": {\n                  \"description\": \"A globally unique ID for the add-on. Usually a database ID. Might be referenced by a DAT application when finding dependencies for other add-ons, or when present in a containsId property.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"name\": {\n                  \"description\": \"The name of the add-on, in UTF-8. This is used for the name of the archive or folder. Must use / for path separators. Names can't end with a period or space.\",\n                  \"$ref\": \"#/$defs/stringFile\"\n                },\n                \"requiresId\": {\n                  \"description\": \"Which titles and updates the specific add-on requires to function, as identified by their globally unique IDs.\",\n                  \"type\": \"array\",\n                  \"minProperties\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/$defs/nonEmptyString\"\n                  }\n                },\n                \"superseded\": {\n                  \"description\": \"Add-ons kept for archival purposes, that are no longer required to update a title to its latest version.\",\n                  \"type\": \"boolean\"\n                }\n              }\n            }\n          },\n          \"group\": {\n            \"description\": \"The name for the group that contains related titles, in UTF-8. For example, the 'Some Video Game ' group might contain 'Some Video Game (USA)', 'Some Video Game (USA) (v1.1)', 'Some Video Game  (Europe)', and 'Some Video Game  (Japan)'.\",\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          },\n          \"id\": {\n            \"description\": \"A globally unique ID for the group. Usually a database ID. Might be referenced by a DAT application when matching compilations against individual titles using the contains array.\",\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          },\n          \"titles\": {\n            \"description\": \"Contains objects that describe the details about each title that is associated with the group.\",\n            \"type\": \"array\",\n            \"minProperties\": 1,\n            \"contains\": {\n              \"type\": \"object\",\n              \"required\": [\"languages\", \"name\", \"regions\", \"sets\"],\n              \"dependentRequired\": {\n                \"subtype\": [\"type\"]\n              },\n              \"additionalProperties\": false,\n              \"allOf\": [\n                {\n                  \"description\": \"The rules that manage what types that subtypes require\",\n                  \"if\": {\n                    \"properties\": {\n                      \"subtype\": {\n                        \"pattern\": \"^(?:Add-on|Audio|Update|Video)$\"\n                      }\n                    }\n                  },\n                  \"then\": {\n                    \"properties\": {\n                      \"type\": {\n                        \"pattern\": \"^(?:Application|Game)$\"\n                      }\n                    }\n                  }\n                },\n                {\n                  \"if\": {\n                    \"properties\": {\n                      \"subtype\": {\n                        \"pattern\": \"^(?:Children|Educational)$\"\n                      }\n                    }\n                  },\n                  \"then\": {\n                    \"properties\": {\n                      \"type\": {\n                        \"pattern\": \"^(?:Application|Audio|Game|Multimedia|Video)$\"\n                      }\n                    }\n                  }\n                },\n                {\n                  \"if\": {\n                    \"properties\": {\n                      \"subtype\": {\n                        \"const\": \"Manual\"\n                      }\n                    }\n                  },\n                  \"then\": {\n                    \"properties\": {\n                      \"type\": {\n                        \"pattern\": \"^(?:Application|Device|Game)$\"\n                      }\n                    }\n                  }\n                }\n              ],\n              \"properties\": {\n                \"build\": {\n                  \"description\": \"When in the software release life cycle the title was released.\",\n                  \"enum\": [\n                    \"Production\",\n                    \"Preproduction\",\n                    \"Release candidate\",\n                    \"Beta\",\n                    \"Alpha\",\n                    \"Prototype\",\n                    \"Development\",\n                    \"Debug\",\n                    \"Review\"\n                  ]\n                },\n                \"contains\": {\n                  \"description\": \"Lists the content that this title contains. Useful for compilations, supersets, and when multiple CDs have been superseded by a DVD release.\",\n                  \"type\": \"array\",\n                  \"minProperties\": 1,\n                  \"contains\": {\n                    \"type\": \"object\",\n                    \"required\": [\"name\"],\n                    \"additionalProperties\": false,\n                    \"properties\": {\n                      \"name\": {\n                        \"$ref\": \"#/$defs/stringFile\"\n                      },\n                      \"groupId\": {\n                        \"$ref\": \"#/$defs/nonEmptyString\"\n                      },\n                      \"includesIds\": {\n                        \"description\": \"The individual titles contained in this release.\",\n                        \"type\": \"array\",\n                        \"minProperties\": 1,\n                        \"contains\": {\n                          \"$ref\": \"#/$defs/nonEmptyString\"\n                        }\n                      },\n                      \"languages\": {\n                        \"$ref\": \"#/$defs/languages\"\n                      },\n                      \"version\": {\n                        \"description\": \"The version as reported by the title or media it came on. For example, Rev 1.\",\n                        \"$ref\": \"#/$defs/nonEmptyString\"\n                      },\n                      \"versionInternal\": {\n                        \"description\": \"An integer-based version assigned by the DAT maintainer, so DAT applications don't have to parse multiple different versioning systems when making 1G1R decisions. This can also help fill the gap in 1G1R selection when the title's releaseDate is unknown. The earliest release is set to 1, with later releases increasing in value. Pre-production titles are included in this version order. Internal versions are only comparable within the same region.\",\n                        \"type\": \"integer\"\n                      }\n                    }\n                  }\n                },\n                \"developer\": {\n                  \"description\": \"The developer of the title.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"id\": {\n                  \"description\": \"A globally unique ID for the title. Usually a database ID. Might be referenced by a DAT application when finding dependencies for add-ons or updates, or when present in a containsId property.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"isAlternate\": {\n                  \"description\": \"Whether the title is an alternate variant of a release.\",\n                  \"type\": \"boolean\"\n                },\n                \"isCompilation\": {\n                  \"description\": \"Whether the title is a compilation.\",\n                  \"type\": \"boolean\"\n                },\n                \"isDemo\": {\n                  \"description\": \"Whether the title is a demo.\",\n                  \"type\": \"boolean\"\n                },\n                \"isLicensed\": {\n                  \"description\": \"Whether the title was sanctioned for release by a platform manufacturer, assuming there was an approval process in place.\",\n                  \"type\": \"boolean\"\n                },\n                \"isMIA\": {\n                  \"description\": \"Whether the title's digests have been verified by more than one person. If not, set the value to true.\",\n                  \"type\": \"boolean\"\n                },\n                \"isPirate\": {\n                  \"description\": \"hether the title contains stolen assets. Often a hack of an existing game that uses intellectual property from other games.\",\n                  \"type\": \"boolean\"\n                },\n                \"isSuperset\": {\n                  \"description\": \"Whether the title contains more content than the original title, or for some reason is superior to another version. For example, game of the year editions, a regional variant with uncensored content, or a DVD version of a title previously released on multiple CDs.\",\n                  \"type\": \"boolean\"\n                },\n                \"languages\": {\n                  \"$ref\": \"#/$defs/languages\",\n                },\n                \"localNames\": {\n                  \"description\": \"Local names given to the title, defined by language.\",\n                  \"type\": \"object\",\n                  \"minProperties\": 1,\n                  \"patternProperties\": {\n                    \"^[a-zA-Z0-9-]+$\": {\n                      \"$ref\": \"#/$defs/nonEmptyString\"\n                    }\n                  }\n                },\n                \"name\": {\n                  \"description\": \"The name of the title, in UTF-8. This is used for the name of the archive or folder. Must use / for path separators. Names can't end with a period or space.\",\n                  \"$ref\": \"#/$defs/stringFile\"\n                },\n                \"peripherals\": {\n                  \"description\": \"Contains inputs used to control the title, or devices that show output from the title.\",\n                  \"type\": \"array\",\n                  \"minItems\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/$defs/peripherals\"\n                  }\n                },\n                \"players\": {\n                  \"decsription\": \"The number of players the title supports.\",\n                  \"type\": \"integer\"\n                },\n                \"playModes\": {\n                  \"decsription\": \"The number of players the title supports.\",\n                  \"type\": \"array\",\n                  \"minitems\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/$defs/playModes\"\n                  }\n                },\n                \"published\": {\n                  \"description\": \"Whether the title was published. Unpublished titles that didn't have an official release should be set to false.\",\n                  \"type\": \"boolean\"\n                },\n                \"publisher\": {\n                  \"description\": \"The publisher of the title.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"regions\": {\n                  \"description\": \"The regions the title was released in.\",\n                  \"type\": \"array\",\n                  \"items\": {\n                    \"anyOf\": [\n                      {\n                        \"$ref\": \"#/$defs/regionsGroup\"\n                      },\n                      {\n                        \"$ref\": \"#/$defs/regionsIndividual\"\n                      }\n                    ]\n                  }\n                },\n                \"releaseDate\": {\n                  \"description\": \"The date the title was released, in extended ISO 8601 format, without the time zone. Valid formats are YYYY-MM-DD hh:mm:ss, YYYY-MM-DD hh:mm, YYYY-MM-DD, YYYY-MM, and YYYY.\",\n                  \"anyOf\": [\n                    {\n                      \"description\": \"YYYY-MM-DD hh:mm:ss\",\n                      \"pattern\": \"^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]:?){1,2}(?&lt;!:)$\"\n                    },\n                    {\n                      \"description\": \"YYYY-MM-DD hh:mm\",\n                      \"pattern\": \"^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9])$\"\n                    },\n                    {\n                      \"description\": \"YYYY-MM-DD\",\n                      \"pattern\": \"^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01]))$\"\n                    },\n                    {\n                      \"description\": \"YYYY-MM\",\n                      \"pattern\": \"^[1-9][0-9]{3,3}-(?:0[1-9]|1[0-2])$\"\n                    },\n                    {\n                      \"description\": \"YYYY\",\n                      \"pattern\": \"^[1-9][0-9]{3,3}$\"\n                    }\n                  ]\n                },\n                \"serial\": {\n                  \"description\": \"A manufacturer identifier for the title. Might be a cartridge serial, disc ring code, or otherwise.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"sets\": {\n                  \"description\": \"Defines the different file sets within the title.\",\n                  \"type\": \"array\",\n                  \"minProperties\": 1,\n                  \"contains\": {\n                    \"type\": \"object\",\n                    \"oneOf\": [\n                      {\n                        \"required\": [\"files\"]\n                      },\n                      {\n                        \"required\": [\"fileset\"]\n                      }\n                    ],\n                    \"additionalProperties\": false,\n                    \"properties\": {\n                      \"comments\": {\n                        \"description\": \"Comments related to the set.\",\n                        \"$ref\": \"#/$defs/nonEmptyString\"\n                      },\n                      \"container\": {\n                        \"description\": \"The container that the DAT application should use for the file set. Must be one of the following values: auto, folder, or null.\",\n                        \"$ref\": \"#/$defs/container\"\n                      },\n                      \"files\": {\n                        \"$ref\": \"#/$defs/files\"\n                      },\n                      \"fileset\": {\n                        \"$ref\": \"#/$defs/fileset\"\n                      },\n                      \"id\": {\n                        \"description\": \"A globally unique ID for the set. Usually a database ID.\",\n                        \"$ref\": \"#/$defs/nonEmptyString\"\n                      },\n                      \"name\": {\n                        \"description\": \"The name of the set. Only required if there is more than one set. Can be any non-empty string, although generally you should use lowercase container format names. For example: bin, chd, iso, files, decrypted, encrypted.\",\n                        \"$ref\": \"#/$defs/nonEmptyString\"\n                      },\n                      \"retroachievements\": {\n                        \"description\": \"Whether retroachievements are support on the title.\",\n                        \"type\": \"boolean\"\n                      }\n                    }\n                  }\n                },\n                \"source\": {\n                  \"description\": \"The title's origin.\",\n                  \"type\": \"array\",\n                  \"minItems\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/$defs/media\"\n                  }\n                },\n                \"subtype\": {\n                  \"description\": \"The subtype of the title. Must be paired with a valid type.\",\n                  \"enum\": [\n                    \"Add-on\",\n                    \"Audio\",\n                    \"Children\",\n                    \"Educational\",\n                    \"Manual\",\n                    \"Update\",\n                    \"Video\"\n                  ]\n                },\n                \"type\": {\n                  \"description\": \"The type of title.\",\n                  \"enum\": [\n                    \"Application\",\n                    \"Audio\",\n                    \"BIOS\",\n                    \"Chip\",\n                    \"Coverdisc\",\n                    \"Device\",\n                    \"Prototype\",\n                    \"Firmware\",\n                    \"Game\",\n                    \"Magazine\",\n                    \"Multimedia\",\n                    \"Video\"\n                  ]\n                },\n                \"version\": {\n                  \"description\": \"The version as reported by the title or media it came on. For example, Rev 1.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"versionInternal\": {\n                  \"description\": \"An integer-based version assigned by the DAT maintainer, so DAT applications don't have to parse multiple different versioning systems when making 1G1R decisions. This can also help fill the gap in 1G1R selection when the title's releaseDate is unknown. The earliest release is set to 1, with later releases increasing in value. Pre-production titles are included in this version order. Internal versions are only comparable within the same region.\",\n                  \"type\": \"integer\"\n                },\n                \"videoStandards\": {\n                  \"description\": \"The video standard supported by the title. This describes a title's fixed output in both color and resolution, as opposed to any monitor standard that might be receiving the output. Use RGB for any title that supports higher resolutions than SVGA, and allows for flexible resolution output.\",\n                  \"type\": \"array\",\n                  \"minProperties\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/$defs/videoStandards\"\n                  }\n                }\n              }\n            }\n          },\n          \"updates\": {\n            \"description\": \"The updates associated with the set.\",\n            \"type\": \"array\",\n            \"contains\": {\n              \"type\": \"object\",\n              \"required\": [\"name\", \"files\"],\n              \"additionalProperties\": false,\n              \"properties\": {\n                \"comments\": {\n                  \"description\": \"Commented related to the update.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"container\": {\n                  \"description\": \"The container that the DAT application should use for the file set. Must be one of the following values: auto, folder, or null.\",\n                  \"$ref\": \"#/$defs/container\"\n                },\n                \"files\": {\n                  \"$ref\": \"#/$defs/files\"\n                },\n                \"id\": {\n                  \"description\": \"A globally unique ID for the update. Usually a database ID. Might be referenced by a DAT application when finding dependencies for add-ons or other updates, or when present in a containsId property.\",\n                  \"$ref\": \"#/$defs/nonEmptyString\"\n                },\n                \"name\": {\n                  \"description\": \"The name of the update, in UTF-8. This is used for the name of the archive or folder. Must use / for path separators. Names can't end with a period or space.\",\n                  \"$ref\": \"#/$defs/stringFile\"\n                },\n                \"requiresId\": {\n                  \"description\": \"Which titles and updates the specific update requires to function, as identified by their globally unique IDs.\",\n                  \"type\": \"array\",\n                  \"minProperties\": 1,\n                  \"items\": {\n                    \"$ref\": \"#/$defs/nonEmptyString\"\n                  }\n                },\n                \"superseded\": {\n                  \"description\": \"Updates kept for archival purposes, that are no longer required to update a title to its latest version.\",\n                  \"type\": \"boolean\"\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  },\n  \"$defs\": {\n    \"nonEmptyString\": {\n      \"type\": \"string\",\n      \"minLength\": 1,\n      \"not\": {\n        \"anyOf\": [\n          {\n            \"pattern\": \"^\\\\s+$\"\n          },\n          {\n            \"pattern\": \"^\\\\s+.*$\"\n          },\n          {\n            \"pattern\": \"\\\\s+$\"\n          }\n        ]\n      }\n    },\n    \"stringNull\": {\n      \"anyOf\": [\n        {\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        {\n          \"type\": \"null\"\n        }\n      ]\n    },\n    \"stringFile\": {\n      \"allOf\": [\n        {\n          \"$ref\": \"#/$defs/nonEmptyString\"\n        },\n        {\n          \"pattern\": \"^[^:&lt;&gt;\\\"\\\\\\\\|?*].*[^. :&lt;&gt;\\\"\\\\\\\\|?*]$\",\n          \"not\": {\n            \"description\": \"Regular expressions to exclude non-UTF-8 characters.\",\n            \"anyOf\": [\n              {\n                \"pattern\": \"[\\\\xC0-\\\\xC1]\"\n              },\n              {\n                \"pattern\": \"[\\\\xF5-\\\\xFF]\"\n              },\n              {\n                \"pattern\": \"\\\\xE0[\\\\x80-\\\\x9F]\"\n              },\n              {\n                \"pattern\": \"\\\\xF0[\\\\x80-\\\\x8F]\"\n              },\n              {\n                \"pattern\": \"[\\\\xC2-\\\\xDF](?![\\\\x80-\\\\xBF])\"\n              },\n              {\n                \"pattern\": \"[\\\\xE0-\\\\xEF](?![\\\\x80-\\\\xBF]{2})\"\n              },\n              {\n                \"pattern\": \"[\\\\xF0-\\\\xF4](?![\\\\x80-\\\\xBF]{3})\"\n              },\n              {\n                \"pattern\": \"(?&lt;=[\\\\x00-\\\\x7F\\\\xF5-\\\\xFF])[\\\\x80-\\\\xBF]\"\n              },\n              {\n                \"pattern\": \"(?&lt;![\\\\xC2-\\\\xDF]|[\\\\xE0-\\\\xEF]|[\\\\xE0-\\\\xEF][\\\\x80-\\\\xBF]|[\\\\xF0-\\\\xF4]|[\\\\xF0-\\\\xF4][\\\\x80-\\\\xBF]|[\\\\xF0-\\\\xF4][\\\\x80-\\\\xBF]{2})[\\\\x80-\\\\xBF]\"\n              },\n              {\n                \"pattern\": \"(?&lt;=[\\\\xE0-\\\\xEF])[\\\\x80-\\\\xBF](?![\\\\x80-\\\\xBF])\"\n              },\n              {\n                \"pattern\": \"(?&lt;=[\\\\xF0-\\\\xF4])[\\\\x80-\\\\xBF](?![\\\\x80-\\\\xBF]{2})\"\n              },\n              {\n                \"pattern\": \"(?&lt;=[\\\\xF0-\\\\xF4][\\\\x80-\\\\xBF])[\\\\x80-\\\\xBF](?![\\\\x80-\\\\xBF])\"\n              }\n            ]\n          }\n        }\n      ]\n    },\n    \"container\": {\n      \"enum\": [\n        \"auto\",\n        \"folder\",\n        null\n      ]\n    },\n    \"digests\": {\n      \"type\": \"object\",\n      \"minProperties\": 1,\n      \"properties\": {\n        \"crc32\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{8,8}$\"\n        },\n        \"md5\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{32,32}$\"\n        },\n        \"sha1\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{40,40}$\"\n        },\n        \"sha1Internal\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{40,40}$\"\n        },\n        \"sha256\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{64,64}$\"\n        },\n        \"xxh3_128\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{32,32}$\"\n        },\n        \"blake3\": {\n          \"type\": \"string\",\n          \"pattern\": \"^[a-fA-F0-9]{64,64}$\"\n        }\n      }\n    },\n    \"files\": {\n      \"description\": \"The files in the set and their properties.\",\n      \"type\": \"array\",\n      \"contains\": {\n        \"type\": \"object\",\n        \"required\": [\"digests\", \"name\", \"size\"],\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"dateModified\": {\n            \"description\": \"The last modified date that should be applied by the DAT application to the file. Because FAT file systems have a time resolution of 2 seconds on last modified dates, you can only use even numbers for the seconds.\",\n            \"type\": \"string\",\n            \"pattern\": \"^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]):(?:[0-5][02468])(?&lt;!:)$\"\n          },\n          \"digests\": {\n            \"description\": \"The digests of different hash functions. The following hash functions are preferred: crc32, sha256, xxh3_128, blake3.\",\n            \"$ref\": \"#/$defs/digests\"\n          },\n          \"header\": {\n            \"description\": \" The header for a ROM, in hex. Aids with addition of the header to a headerless ROM, or removal from a headered ROM.\",\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          },\n          \"name\": {\n            \"description\": \"The name of the file, in UTF-8. Must use / for path separators. Names can't end with a period or space.\",\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          },\n          \"size\": {\n            \"description\": \"The size of the file, in bytes.\",\n            \"type\": \"integer\"\n          }\n        }\n      }\n    },\n    \"fileset\": {\n      \"description\": \"Multiple groups of files and their properties. Useful for bundling together separate parts of a title. For example, multiple discs in a single release.\",\n      \"type\": \"array\",\n      \"contains\": {\n        \"type\": \"object\",\n        \"if\": {\n          \"properties\": {\n            \"container\": {\n              \"type\": \"null\"\n            }\n          }\n        },\n        \"then\": {\n          \"required\": [\"files\"]\n        },\n        \"else\": {\n          \"required\": [\"files\", \"name\"]\n        },\n        \"additionalProperties\": false,\n        \"properties\": {\n          \"comments\": {\n            \"description\": \"Comments related to the fileset.\",\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          },\n          \"container\": {\n            \"description\": \"The container that the DAT application should use for the file set. Must be one of the following values: auto, folder, or null.\",\n            \"$ref\": \"#/$defs/container\"\n          },\n          \"files\": {\n            \"$ref\": \"#/$defs/files\"\n          },\n          \"id\": {\n            \"description\": \"A globally unique ID for the title. Usually a database ID.\",\n            \"$ref\": \"#/$defs/nonEmptyString\"\n          },\n          \"name\": {\n            \"description\": \"Overrides the title name key to become the archive or folder name used for the set.\",\n            \"$ref\": \"#/$defs/stringFile\"\n          }\n        }\n      }\n    },\n    \"languages\": {\n      \"description\": \"The languages the title supports.\",\n      \"type\": \"object\",\n      \"required\": [\"audio\", \"interface\", \"subtitles\"],\n      \"additionalProperties\": false,\n      \"properties\": {\n        \"audio\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/$defs/stringNull\"\n          }\n        },\n        \"interface\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/$defs/stringNull\"\n          }\n        },\n        \"subtitles\": {\n          \"type\": \"array\",\n          \"items\": {\n            \"$ref\": \"#/$defs/stringNull\"\n          }\n        }\n      }\n    },\n    \"media\": {\n      \"enum\": [\n        \"3.5\\\" floppy disk\",\n        \"5.25\\\" floppy disk\",\n        \"BD-ROM\",\n        \"BD-ROM (Ultra HD)\",\n        \"Cassette tape\",\n        \"CD-ROM\",\n        \"Device\",\n        \"Digital\",\n        \"DVD-ROM\",\n        \"Famicom Disk\",\n        \"GameCube Game Disc\",\n        \"Game Card\",\n        \"GD-ROM\",\n        \"Hard Drive\",\n        \"HD-DVD\",\n        \"HuCard\",\n        \"LaserDisc\",\n        \"Memory Card\",\n        \"ROM Card\",\n        \"ROM Cartridge\",\n        \"UMD\",\n        \"VHS\",\n        \"Wii Optical Disc\",\n        \"Wii U Optical Disc\"\n      ]\n    },\n    \"peripherals\": {\n      \"enum\": [\n        \"Controller\",\n        \"Controller with Touchpad\",\n        \"Controller with Trackball\",\n        \"Analog Joystick\",\n        \"Dance Pad\",\n        \"Digital Joystick\",\n        \"Digital Twin Sticks\",\n        \"Drums\",\n        \"EyeToy\",\n        \"Flight Stick\",\n        \"Guitar\",\n        \"HOTAS\",\n        \"Keyboard\",\n        \"Light Gun\",\n        \"Magnavox Odyssey Controller\",\n        \"Microphone\",\n        \"Microsoft Kinect\",\n        \"Microsoft Xbox Live Vision\",\n        \"Mouse\",\n        \"Nintendo Joy-Con\",\n        \"Nintendo Wii Balance Board\",\n        \"Nintendo Wii Remote\",\n        \"Nintendo Wii Remote and Nunchuk\",\n        \"Nintendo Power Glove\",\n        \"Pedals\",\n        \"Sega Dreamcast VMU\",\n        \"Sony EyeToy\",\n        \"Sony PlayStation Eye\",\n        \"Sony PlayStation Move\",\n        \"Sony Sixaxis\",\n        \"Spinner\",\n        \"Steering Wheel (Lock-to-lock)/Paddle\",\n        \"Steering Wheel (360\u00b0)\",\n        \"Touchscreen\",\n        \"Trackball\",\n        \"VR Headset\",\n        \"VR Headset and Controls\"\n      ]\n    },\n    \"playModes\": {\n      \"enum\": [\n        \"Single Player\",\n        \"Co-op (Split-screen)\",\n        \"Co-op (Local)\",\n        \"Co-op (Online)\",\n        \"Competitive (Split-screen Free-for-all)\",\n        \"Competitive (Split-screen Team)\",\n        \"Competitive (Local Free-for-all)\",\n        \"Competitive (Local Team)\",\n        \"Competitive (Online Free-for-all)\",\n        \"Competitive (Online Team)\"\n      ]\n    },\n    \"regionsGroup\": {\n      \"enum\": [\n        \"AFR\",\n        \"ASI\",\n        \"EUR\",\n        \"GLO\",\n        \"LAM\",\n        \"MDE\",\n        \"NAM\",\n        \"NOR\",\n        \"OCE\",\n        \"SAM\"\n      ]\n    },\n    \"regionsIndividual\": {\n      \"enum\": [\n        \"AD\",\n        \"AE\",\n        \"AF\",\n        \"AG\",\n        \"AI\",\n        \"AL\",\n        \"AM\",\n        \"AO\",\n        \"AQ\",\n        \"AR\",\n        \"AS\",\n        \"AT\",\n        \"AU\",\n        \"AW\",\n        \"AX\",\n        \"AZ\",\n        \"BA\",\n        \"BB\",\n        \"BD\",\n        \"BE\",\n        \"BF\",\n        \"BG\",\n        \"BH\",\n        \"BI\",\n        \"BJ\",\n        \"BL\",\n        \"BM\",\n        \"BN\",\n        \"BO\",\n        \"BQ\",\n        \"BR\",\n        \"BS\",\n        \"BT\",\n        \"BV\",\n        \"BW\",\n        \"BY\",\n        \"BZ\",\n        \"CA\",\n        \"CC\",\n        \"CD\",\n        \"CF\",\n        \"CG\",\n        \"CH\",\n        \"CI\",\n        \"CK\",\n        \"CL\",\n        \"CM\",\n        \"CN\",\n        \"CO\",\n        \"CR\",\n        \"CU\",\n        \"CV\",\n        \"CW\",\n        \"CX\",\n        \"CY\",\n        \"CZ\",\n        \"DE\",\n        \"DJ\",\n        \"DK\",\n        \"DM\",\n        \"DO\",\n        \"DZ\",\n        \"EC\",\n        \"EE\",\n        \"EG\",\n        \"EH\",\n        \"ER\",\n        \"ES\",\n        \"ET\",\n        \"FI\",\n        \"FJ\",\n        \"FK\",\n        \"FM\",\n        \"FO\",\n        \"FR\",\n        \"GA\",\n        \"GB\",\n        \"GD\",\n        \"GE\",\n        \"GF\",\n        \"GG\",\n        \"GH\",\n        \"GI\",\n        \"GL\",\n        \"GM\",\n        \"GN\",\n        \"GP\",\n        \"GQ\",\n        \"GR\",\n        \"GS\",\n        \"GT\",\n        \"GU\",\n        \"GW\",\n        \"GY\",\n        \"HK\",\n        \"HM\",\n        \"HN\",\n        \"HR\",\n        \"HT\",\n        \"HU\",\n        \"ID\",\n        \"IE\",\n        \"IL\",\n        \"IM\",\n        \"IN\",\n        \"IO\",\n        \"IQ\",\n        \"IR\",\n        \"IS\",\n        \"IT\",\n        \"JE\",\n        \"JM\",\n        \"JO\",\n        \"JP\",\n        \"KE\",\n        \"KG\",\n        \"KH\",\n        \"KI\",\n        \"KM\",\n        \"KN\",\n        \"KP\",\n        \"KR\",\n        \"KW\",\n        \"KY\",\n        \"KZ\",\n        \"LA\",\n        \"LB\",\n        \"LC\",\n        \"LI\",\n        \"LK\",\n        \"LR\",\n        \"LS\",\n        \"LT\",\n        \"LU\",\n        \"LV\",\n        \"LY\",\n        \"MA\",\n        \"MC\",\n        \"MD\",\n        \"ME\",\n        \"MF\",\n        \"MG\",\n        \"MH\",\n        \"MK\",\n        \"ML\",\n        \"MM\",\n        \"MN\",\n        \"MO\",\n        \"MP\",\n        \"MQ\",\n        \"MR\",\n        \"MS\",\n        \"MT\",\n        \"MU\",\n        \"MV\",\n        \"MW\",\n        \"MX\",\n        \"MY\",\n        \"MZ\",\n        \"NA\",\n        \"NC\",\n        \"NE\",\n        \"NF\",\n        \"NG\",\n        \"NI\",\n        \"NL\",\n        \"NO\",\n        \"NP\",\n        \"NR\",\n        \"NU\",\n        \"NZ\",\n        \"OM\",\n        \"PA\",\n        \"PE\",\n        \"PF\",\n        \"PG\",\n        \"PH\",\n        \"PK\",\n        \"PL\",\n        \"PM\",\n        \"PN\",\n        \"PR\",\n        \"PS\",\n        \"PT\",\n        \"PW\",\n        \"PY\",\n        \"QA\",\n        \"RE\",\n        \"RO\",\n        \"RS\",\n        \"RU\",\n        \"RW\",\n        \"SA\",\n        \"SB\",\n        \"SC\",\n        \"SD\",\n        \"SE\",\n        \"SG\",\n        \"SH\",\n        \"SI\",\n        \"SJ\",\n        \"SK\",\n        \"SL\",\n        \"SM\",\n        \"SN\",\n        \"SO\",\n        \"SR\",\n        \"SS\",\n        \"ST\",\n        \"SV\",\n        \"SX\",\n        \"SY\",\n        \"SZ\",\n        \"TC\",\n        \"TD\",\n        \"TF\",\n        \"TG\",\n        \"TH\",\n        \"TJ\",\n        \"TK\",\n        \"TL\",\n        \"TM\",\n        \"TN\",\n        \"TO\",\n        \"TR\",\n        \"TT\",\n        \"TV\",\n        \"TW\",\n        \"TZ\",\n        \"UA\",\n        \"UG\",\n        \"UM\",\n        \"US\",\n        \"UY\",\n        \"UZ\",\n        \"VA\",\n        \"VC\",\n        \"VE\",\n        \"VG\",\n        \"VI\",\n        \"VN\",\n        \"VU\",\n        \"WF\",\n        \"WS\",\n        \"YE\",\n        \"YT\",\n        \"ZA\",\n        \"ZM\",\n        \"ZW\"\n      ]\n    },\n    \"videoStandards\": {\n      \"enum\": [\n        \"4K Ultra HD\",\n        \"8K Ultra HD\",\n        \"AX-VGA\",\n        \"CGA\",\n        \"EGA\",\n        \"EVGA\",\n        \"HGC\",\n        \"HDTV (720i)\",\n        \"HDTV (720p)\",\n        \"Full HDTV (1080i)\",\n        \"Full HDTV (1080p)\",\n        \"JEGA\",\n        \"MCGA\",\n        \"MDA\",\n        \"MPAL\",\n        \"NTSC\",\n        \"NTSC (DV) (480i)\",\n        \"NTSC (DV) (480p)\",\n        \"PAL\",\n        \"PAL (DV) (576i)\",\n        \"PAL (DV) (576p)\",\n        \"PAL 60Hz\",\n        \"PGC\",\n        \"Plantronics\",\n        \"Quadcolor\",\n        \"RGB\",\n        \"SECAM\",\n        \"SVGA\",\n        \"Tandy\",\n        \"TIGA\",\n        \"VGA\",\n        \"XGA\"\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"sets/","title":"<code>sets</code>","text":"<p>The <code>sets</code> array contains objects that represent different file sets within a <code>title</code>. For example, you might have a file set which describes both the BIN+CUE version of a title, and the CHD version.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"sets\": [\n  {\n    \"name\": \"bin\",\n    \"container\": \"auto\",\n    \"id\": \"654321\",\n    \"comments\": \"Something relevant about the set\",\n    \"retroachievements\": true,\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"name\": \"chd\",\n    \"files\": [\n        ...\n    ]\n  }\n]\n</code></pre> <p>There must be a minimum of one file set in the <code>sets</code> array. If there is more than one file set, then DAT applications should let the user choose which file set or file sets they want to keep based on the <code>name</code>, and let them assign different output paths per file set.</p> <p>This capability means a single DAT file can cover multiple formats. For example, a disc image in ISO, CHD, and RVZ formats. Or a ROM in encrypted and decrypted formats. A user can keep one file set or many, routing the output for each to different paths if they want.</p> Expand for developer details <p>Don't allow different sets to be assigned to the same folder, or you could end up with naming clashes.</p>"},{"location":"sets/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>files</code> <code>object array</code> <code>conditionally required</code></p> <p>The files in the set and their properties.</p> <p>Condition: You must use either the <code>files</code> array at this level, or the <code>fileset</code> array, not both.</p> <p>Read more about the <code>files</code> array.</p> </li> <li> <p><code>fileset</code> <code>object array</code> <code>conditionally required</code></p> <p>Multiple groups of <code>files</code> and their properties. Useful for bundling together separate parts of a title. For example, multiple discs in a single release.</p> <p>Condition: You must use either the <code>files</code> array at this level, or the <code>fileset</code> array, not both.</p> <p>Read more about the <code>fileset</code> array.</p> </li> </ul>"},{"location":"sets/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>comments</code> <code>string</code> <code>optional</code></p> <p>Comments related to the set.</p> </li> <li> <p><code>container</code> <code>string</code> <code>optional</code></p> <p>The container that the DAT application should use for the file set. Must be one of the following values:</p> <ul> <li> <p><code>auto</code>: Store the files in whatever container the user chooses in the DAT   application. For example, a ZIP file, a 7Z file, a folder, or no container. The base   file name of the container matches the title <code>name</code>.</p> </li> <li> <p><code>folder</code>: Store the files in a folder named after the title   <code>name</code>.</p> </li> <li> <p><code>null</code>: Don't store the files in any container. Useful for keeping files by   themselves, or for treating archives as files.</p> </li> </ul> <p>If this property isn't present, the DAT application assumes the value is <code>auto</code>.</p> Expand for developer details <p>A <code>container</code> at the <code>sets</code> level with an <code>auto</code> value likely has a different behavior depending on whether or not it applies to a <code>files</code> or <code>fileset</code> array.</p> <p>For example, when dealing with a <code>files</code> array, <code>auto</code> might correlate with a <code>null</code> value, meaning you get raw files. When dealing with a <code>fileset</code> array, <code>auto</code> might correlate with a folder. This means the following scenario can be supported, where multidisc titles are put in a subfolder, but single disc titles are kept in a root folder:</p> <pre><code>\u25cf [folder] Root folder\n    \u251c [file] Some Video Game (USA).iso\n    \u251c [file] Some Video Game, Other (Japan).iso\n    \u251c [folder] Some Video Game, The Sequel (USA)\n    \u2502   \u251c [file] Some Video Game, The Sequel (USA) (Disc 1).iso\n    \u2502   \u2514 [file] Some Video Game, The Sequel (USA) (Disc 2).iso\n    \u2514 [file] Yet Another Video game (USA).iso\n</code></pre> </li> <li> <p><code>id</code> <code>string</code> <code>optional</code></p> <p>A globally unique ID for the set item. Usually a database ID to ease lookups for DAT file maintainers.</p> </li> <li> <p><code>name</code> <code>string</code> <code>optional</code></p> <p>The name of the set. Only required if there is more than one set.</p> <p>Can be any non-empty string, although generally you should use lowercase container format names. For example:</p> <ul> <li> <p><code>bin</code></p> </li> <li> <p><code>chd</code></p> </li> <li> <p><code>ciso</code></p> </li> <li> <p><code>gdi</code></p> </li> <li> <p><code>iso</code></p> </li> <li> <p><code>rvz</code></p> </li> <li> <p><code>xiso</code></p> </li> </ul> <p>Use the following for decrypted and encrypted content:</p> <ul> <li> <p><code>decrypted</code></p> </li> <li> <p><code>encrypted</code></p> </li> </ul> <p>Use the following for files that shouldn't be stored in a container:</p> <ul> <li><code>files</code></li> </ul> </li> <li> <p><code>retroachievements</code> <code>boolean</code> <code>optional</code></p> <p>Whether or not retroachievements are supported on the title.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> </ul>"},{"location":"structure/","title":"Structure","text":"<p>The following sections include examples of DAT file structures. They are presented piecemeal to help ease understanding. For a complete example of a valid DAT file, see Basic example.</p> <p>In code samples, <code>...</code> is used where data has been omitted for brevity and ease of understanding. This omitted data might contain required information to validate successfully against the schema.</p> <p>The string <code>...</code> is not valid JSON and should not be included in DAT files.</p>"},{"location":"structure/#global-rules","title":"Global rules","text":"<p>When creating DAT files, keep the following rules in mind:</p> <ul> <li> <p>DAT files must be valid JSON.</p> </li> <li> <p>String values can't have leading or trailing whitespace.</p> </li> <li> <p>DAT files must pass the schema.</p> </li> </ul>"},{"location":"titles/","title":"<code>titles</code>","text":"<p>The <code>titles</code> array contains objects that describe the details about each title that is associated with a group.</p> <p>While many of the properties in the <code>titles</code> array are optional, the more that are included, the more that a DAT application is able to filter on.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"titles\": [\n  {\n    \"name\": \"Some Video Game (USA)\",\n    \"id\": \"123456\",\n    \"build\": \"Production\",\n    \"published\": true,\n    \"type\": \"Game\",\n    \"subtype\": \"Educational\",\n    \"releaseDate\": \"1993-10-12\",\n    \"version\": \"Rev 1\",\n    \"versionInternal\": 1,\n    \"serial\": \"SLUS-000000\",\n    \"isAlternate\": false,\n    \"isCompilation\": false,\n    \"isDemo\": false,\n    \"isLicensed\": false,\n    \"isMIA\": false,\n    \"isPirate\": false,\n    \"isSuperset\": false,\n    \"contains\": [],\n    \"regions\": [\"US\"],\n    \"languages\": {\n      \"audio\": [\"en\", \"ja\"],\n      \"interface\": [\"en\"],\n      \"subtitles\": [\"en\"]\n    },\n    \"localNames\": [\n      \"en\": \"Some Video Game\",\n      \"ja\": \"\u5225\u306e\u30d3\u30c7\u30aa\u30b2\u30fc\u30e0\"\n    ],\n    \"developer\": \"That Game Dev\",\n    \"publisher\": \"That Game Publisher\",\n    \"source\": [\"3.5\\\" Floppy Disk\"],\n    \"peripherals\": [\"Keyboard\", \"Mouse\"],\n    \"players\": 4,\n    \"playModes\": [\"Single Player\", \"Competitive (Online Free-for-all)\"],\n    \"videoStandards\": [\"NTSC\"],\n    \"sets\": [\n      ...\n    ]\n  }\n]\n</code></pre>"},{"location":"titles/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the title, in UTF-8. Must be globally unique. This is used for the name of the archive or folder of the contained sets, under the following conditions:</p> <ul> <li> <p>The <code>container</code> of the set isn't set to <code>null</code>.</p> </li> <li> <p>The <code>name</code> of the set isn't defined.</p> </li> </ul> <p>Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\|?*].*[^. :&lt;&gt;\\\"\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>regions</code> <code>enum array</code> <code>required</code></p> <p>Which regions the title was released in. Valid individual region codes are two characters long, and are described in ISO 3166-1 alpha-2. Grouped regions are three characters long, and defined entirely by this standard.</p> <p>The following general rules apply:</p> <ul> <li> <p>If you don't know where a title is from, use an empty array:</p> <pre><code>\"regions\": []\n</code></pre> </li> <li> <p>If you do know where a title is from, prefer listing individual regions over grouped   regions where possible for better granularity.</p> </li> <li> <p>Region codes should always be listed in alphabetical order.</p> </li> </ul> <p>For grouped regions, keep the following rules in mind:</p> <ul> <li> <p>Only use grouped regions by themselves when a title is clearly intended for release   in that broad area. For example, titles have often been released for Europe due to   the PAL video standard, some other form of region locking, or because of the   level of English comprehension of the continent.   Digitally-distributed titles often have only one global version.</p> </li> <li> <p>When using grouped regions, be aware that each can contain several individual   regions that have vastly different languages, even within those individual   regions. It's not good enough to have a grouped region listed without its languages   \u2014 just <code>ASI</code> (Asia) by itself tells us nothing about who the target audience   is. Be extra diligent in adding all the supported languages for the title, even if   this means testing to find out.</p> </li> <li> <p>If you have more than two individual regions listed that belong to a grouped region,   also add that grouped region. For example, if a title was released in France and   Germany, it's also worth adding Europe: <code>[\"FR\", \"DE\", \"EUR\"]</code>. Be aware that   individual regions can be part of multiple grouped regions. For example, T\u00fcrkiye is   a melting pot of cultures at the intersection of Asia, Europe, and the Middle East.   Mexico is part of North America, but also Latin America.</p> </li> </ul> <p>The valid regions are as follows:</p> Individual regionsGrouped regions <p></p> <p><ul> <li><code>AF</code> - Afghanistan</li> <li><code>AX</code> - \u00c5land Islands</li> <li><code>AL</code> - Albania</li> <li><code>DZ</code> - Algeria</li> <li><code>AS</code> - American Samoa</li> <li><code>AD</code> - Andorra</li> <li><code>AO</code> - Angola</li> <li><code>AI</code> - Anguilla</li> <li><code>AQ</code> - Antarctica</li> <li><code>AG</code> - Antigua and Barbuda</li> <li><code>AR</code> - Argentina</li> <li><code>AM</code> - Armenia</li> <li><code>AW</code> - Aruba</li> <li><code>AU</code> - Australia</li> <li><code>AT</code> - Austria</li> <li><code>AZ</code> - Azerbaijan</li> <li><code>BS</code> - Bahamas</li> <li><code>BH</code> - Bahrain</li> <li><code>BD</code> - Bangladesh</li> <li><code>BB</code> - Barbados</li> <li><code>BY</code> - Belarus</li> <li><code>BE</code> - Belgium</li> <li><code>BZ</code> - Belize</li> <li><code>BJ</code> - Benin</li> <li><code>BM</code> - Bermuda</li> <li><code>BT</code> - Bhutan</li> <li><code>BO</code> - Bolivia</li> <li><code>BQ</code> - Bonaire, Sint Eustatius and Saba</li> <li><code>BA</code> - Bosnia and Herzegovina</li> <li><code>BW</code> - Botswana</li> <li><code>BV</code> - Bouvet Island</li> <li><code>BR</code> - Brazil</li> <li><code>IO</code> - British Indian Ocean Territory</li> <li><code>BN</code> - Brunei  Darussalam</li> <li><code>BG</code> - Bulgaria</li> <li><code>BF</code> - Burkina Faso</li> <li><code>BI</code> - Burundi</li> <li><code>CV</code> - Cabo Verde</li> <li><code>KH</code> - Cambodia</li> <li><code>CM</code> - Cameroon</li> <li><code>CA</code> - Canada</li> <li><code>KY</code> - Cayman Islands</li> <li><code>CF</code> - Central African Republic</li> <li><code>TD</code> - Chad</li> <li><code>CL</code> - Chile</li> <li><code>CN</code> - China</li> <li><code>CX</code> - Christmas Island</li> <li><code>CC</code> - Cocos (Keeling) Islands</li> <li><code>CO</code> - Colombia</li> <li><code>KM</code> - Comoros</li> <li><code>CG</code> - Congo</li> <li><code>CD</code> - Congo, Democratic Republic of the</li> <li><code>CK</code> - Cook Islands</li> <li><code>CR</code> - Costa Rica</li> <li><code>CI</code> - C\u00f4te d'Ivoire</li> <li><code>HR</code> - Croatia</li> <li><code>CU</code> - Cuba</li> <li><code>CW</code> - Cura\u00e7ao</li> <li><code>CY</code> - Cyprus</li> <li><code>CZ</code> - Czechia</li> <li><code>DK</code> - Denmark</li> <li><code>DJ</code> - Djibouti</li> <li><code>DM</code> - Dominica</li> <li><code>DO</code> - Dominican Republic</li> <li><code>EC</code> - Ecuador</li> <li><code>EG</code> - Egypt</li> <li><code>SV</code> - El Salvador</li> <li><code>GQ</code> - Equatorial Guinea</li> <li><code>ER</code> - Eritrea</li> <li><code>EE</code> - Estonia</li> <li><code>SZ</code> - Eswatini</li> <li><code>ET</code> - Ethiopia</li> <li><code>FK</code> - Falkland Islands</li> <li><code>FO</code> - Faroe Islands</li> <li><code>FJ</code> - Fiji</li> <li><code>FI</code> - Finland</li> <li><code>FR</code> - France</li> <li><code>GF</code> - French Guiana</li> <li><code>PF</code> - French Polynesia</li> <li><code>TF</code> - French Southern Territories</li> <li><code>GA</code> - Gabon</li> <li><code>GM</code> - Gambia</li> <li><code>GE</code> - Georgia</li> <li><code>DE</code> - Germany</li> <li><code>GH</code> - Ghana</li> <li><code>GI</code> - Gibraltar</li> <li><code>GR</code> - Greece</li> <li><code>GL</code> - Greenland</li> <li><code>GD</code> - Grenada</li> <li><code>GP</code> - Guadeloupe</li> <li><code>GU</code> - Guam</li> <li><code>GT</code> - Guatemala</li> <li><code>GG</code> - Guernsey</li> <li><code>GN</code> - Guinea</li> <li><code>GW</code> - Guinea-Bissau</li> <li><code>GY</code> - Guyana</li> <li><code>HT</code> - Haiti</li> <li><code>HM</code> - Heard Island and McDonald Islands</li> <li><code>VA</code> - Holy-See</li> <li><code>HN</code> - Honduras</li> <li><code>HK</code> - Hong Kong</li> <li><code>HU</code> - Hungary</li> <li><code>IS</code> - Iceland</li> <li><code>IN</code> - India</li> <li><code>ID</code> - Indonesia</li> <li><code>IR</code> - Iran, Islamic Republic of</li> <li><code>IQ</code> - Iraq</li> <li><code>IE</code> - Ireland</li> <li><code>IM</code> - Isle of Man</li> <li><code>IL</code> - Israel</li> <li><code>IT</code> - Italy</li> <li><code>JM</code> - Jamaica</li> <li><code>JP</code> - Japan</li> <li><code>JE</code> - Jersey</li> <li><code>JO</code> - Jordan</li> <li><code>KZ</code> - Kazakhstan</li> <li><code>KE</code> - Kenya</li> <li><code>KI</code> - Kiribati</li> <li><code>KP</code> - Korea, Democratic People's Republic of (North Korea)</li> <li><code>KR</code> - Korea, Republic of (South Korea)</li> <li><code>KW</code> - Kuwait</li> <li><code>KG</code> - Kyrgyzstan</li> <li><code>LA</code> - Lao People's Democratic Republic (Laos)</li> <li><code>LV</code> - Latvia</li> <li><code>LB</code> - Lebanon</li> <li><code>LS</code> - Lesotho</li> <li><code>LR</code> - Liberia</li> <li><code>LY</code> - Libya</li> <li><code>LI</code> - Liechtenstein</li> <li><code>LT</code> - Lithuania</li> <li><code>LU</code> - Luxembourg</li> <li><code>MO</code> - Macao</li> <li><code>MG</code> - Madagascar</li> <li><code>MW</code> - Malawi</li> <li><code>MY</code> - Malaysia</li> <li><code>MV</code> - Maldives</li> <li><code>ML</code> - Mali</li> <li><code>MT</code> - Malta</li> <li><code>MH</code> - Marshall Islands</li> <li><code>MQ</code> - Martinique</li> <li><code>MR</code> - Mauritania</li> <li><code>MU</code> - Mauritius</li> <li><code>YT</code> - Mayotte</li> <li><code>MX</code> - Mexico</li> <li><code>FM</code> - Micronesia, Federated States of</li> <li><code>MD</code> - Moldova, Republic of</li> <li><code>MC</code> - Monaco</li> <li><code>MN</code> - Mongolia</li> <li><code>ME</code> - Montenegro</li> <li><code>MS</code> - Montserrat</li> <li><code>MA</code> - Morocco</li> <li><code>MZ</code> - Mozambique</li> <li><code>MM</code> - Myanmar</li> <li><code>NA</code> - Namibia</li> <li><code>NR</code> - Nauru</li> <li><code>NP</code> - Nepal</li> <li><code>NL</code> - Netherlands, Kingdom of the</li> <li><code>NC</code> - New Caledonia</li> <li><code>NZ</code> - New Zealand</li> <li><code>NI</code> - Nicaragua</li> <li><code>NE</code> - Niger</li> <li><code>NG</code> - Nigeria</li> <li><code>NU</code> - Niue</li> <li><code>NF</code> - Norfolk Island</li> <li><code>MK</code> - North Macedonia</li> <li><code>MP</code> - Northern Mariana Islands</li> <li><code>NO</code> - Norway</li> <li><code>OM</code> - Oman</li> <li><code>PK</code> - Pakistan</li> <li><code>PW</code> - Palau</li> <li><code>PS</code> - Palestine, Sate of</li> <li><code>PA</code> - Panama</li> <li><code>PG</code> - Papua New Guinea</li> <li><code>PY</code> - Paraguay</li> <li><code>PE</code> - Peru</li> <li><code>PH</code> - Philippines</li> <li><code>PN</code> - Pitcairn</li> <li><code>PL</code> - Poland</li> <li><code>PT</code> - Portugal</li> <li><code>PR</code> - Puerto Rico</li> <li><code>QA</code> - Qatar</li> <li><code>RE</code> - R\u00e9union</li> <li><code>RO</code> - Romania</li> <li><code>RU</code> - Russian Federation (Russia)</li> <li><code>RW</code> - Rwanda</li> <li><code>BL</code> - Saint Barth\u00e9lemy</li> <li><code>SH</code> - Saint Helena, Ascension and Tristan da Cunha</li> <li><code>KN</code> - Saint Kitts &amp; Nevis</li> <li><code>LC</code> - Saint Lucia</li> <li><code>PM</code> - Saint Pierre &amp; Miquelon</li> <li><code>VC</code> - Saint Vincent and the Grenadines</li> <li><code>WS</code> - Samoa</li> <li><code>SM</code> - San Marino</li> <li><code>ST</code> - Sao Tome &amp; Principe</li> <li><code>SA</code> - Saudi Arabia</li> <li><code>SN</code> - Senegal</li> <li><code>RS</code> - Serbia</li> <li><code>SC</code> - Seychelles</li> <li><code>SL</code> - Sierra Leone</li> <li><code>SG</code> - Singapore</li> <li><code>SX</code> - Sint Maarten (Dutch)</li> <li><code>MF</code> - Sint Maarten (French)</li> <li><code>SK</code> - Slovakia</li> <li><code>SI</code> - Slovenia</li> <li><code>SB</code> - Solomon Islands</li> <li><code>SO</code> - Somalia</li> <li><code>ZA</code> - South Africa</li> <li><code>GS</code> - South Georgia and the South Sandwich Islands</li> <li><code>SS</code> - South Sudan</li> <li><code>ES</code> - Spain</li> <li><code>LK</code> - Sri Lanka</li> <li><code>SD</code> - Sudan</li> <li><code>SR</code> - Suriname</li> <li><code>SJ</code> - Svalbard and Jan Mayen</li> <li><code>SE</code> - Sweden</li> <li><code>CH</code> - Switzerland</li> <li><code>SY</code> - Syrian Arab Republic (Syria)</li> <li><code>TW</code> - Taiwan, Province of China</li> <li><code>TJ</code> - Tajikstan</li> <li><code>TZ</code> - Tanzania, United Republic of</li> <li><code>TH</code> - Thailand</li> <li><code>TL</code> - Timor-Leste</li> <li><code>TG</code> - Togo</li> <li><code>TK</code> - Tokelau</li> <li><code>TO</code> - Tonga</li> <li><code>TT</code> - Trinidad and Tobago</li> <li><code>TN</code> - Tunisia</li> <li><code>TR</code> - T\u00fcrkiye</li> <li><code>TM</code> - Turkmenistan</li> <li><code>TC</code> - Turks and Caicos Islands</li> <li><code>TV</code> - Tuvalu</li> <li><code>UG</code> - Uganda</li> <li><code>UA</code> - Ukraine</li> <li><code>AE</code> - United Arab Emirates</li> <li><code>GB</code> - United Kingdom of Great Britain and Northern Ireland</li> <li><code>UM</code> - United States Minor Outlying Islands</li> <li><code>US</code> - United States of America</li> <li><code>UY</code> - Uruguay</li> <li><code>UZ</code> - Uzbekistan</li> <li><code>VU</code> - Vanuatu</li> <li><code>VE</code> - Venezuela, Bolivarian Republic of</li> <li><code>VN</code> - Viet Nam (Vietnam)</li> <li><code>VG</code> - Virgin Islands (British)</li> <li><code>VI</code> - Virgin Islands (U.S.)</li> <li><code>WF</code> - Wallis and Futuna</li> <li><code>EH</code> - Western Sahara</li> <li><code>YE</code> - Yemen</li> <li><code>ZM</code> - Zambia</li> <li><code>ZW</code> - Zimbabwe</li> </ul></p> <ul> <li> <p><code>GLO</code> - Global</p> </li> <li> <p><code>AFR</code> - Africa</p> </li> <li> <p><code>ASI</code> - Asia</p> </li> <li> <p><code>EUR</code> - Europe</p> </li> <li> <p><code>LAM</code> - Latin America</p> </li> <li> <p><code>MDE</code> - Middle East</p> </li> <li> <p><code>NAM</code> - North America</p> </li> <li> <p><code>NOR</code> - Nordics</p> </li> <li> <p><code>OCE</code> - Oceania</p> </li> <li> <p><code>SAM</code> - South America</p> </li> </ul> <p>Regions in graphical user interfaces</p> <p>These region codes are intended to keep the character count of the <code>regions</code> array, and therefore the file size, down. When building graphical user interfaces, opt to use full region names to keep it more accessible to users.</p> </li> <li> <p><code>languages</code> <code>object</code> <code>required</code></p> <p>The supported languages for the title's <code>audio</code>, <code>interface</code>, and <code>subtitles</code>. If there are no audio, interface, or subtitle languages, add a singular <code>null</code> item to the relevant arrays:</p> <pre><code>\"languages\": {\n  \"audio\": [null],\n  \"interface\": [\"en\"],\n  \"subtitles\": [null]\n}\n</code></pre> <p>If you don't know what languages are supported and aren't able to test to find out, leave the arrays empty. This isn't recommended. A sincere effort to catalog supported languages should be made \u2014 more data helps us all.</p> <pre><code>\"languages\": {\n  \"audio\": [],\n  \"interface\": [],\n  \"subtitles\": []\n}\n</code></pre> <p>Constructing language codes</p> <p>Valid language codes are listed in the IANA language subtag registry. You can search for and validate a language code at BCP47 language subtag lookup. Here are some example codes:</p> <ul> <li> <p><code>en</code> - English</p> </li> <li> <p><code>en-US</code> - English (United States of America)</p> </li> <li> <p><code>zh-Hant</code> - Chinese (Traditional) [written]</p> </li> <li> <p><code>cmn</code> - Chinese (Mandarin) [spoken]</p> </li> </ul> <p>There are well over 9,000 subtags that can be combined in different ways to create a language code, so for page performance they're not listed here. It's also not sensible to include that much data in the schema validation, so validation needs to be done by the code generating the DAT file.</p> <p>To learn more about language codes, see the following pages:</p> <ul> <li> <p>Language tags in HTML and XML</p> </li> <li> <p>Choosing a language tag</p> </li> <li> <p>Simplified vs. Traditional Chinese, and the Spoken Dialects     (Chinese language codes differ for spoken vs written)</p> </li> </ul> <p>Choosing languages</p> <p>In all circumstances, consider the intended audience of the medium when selecting language codes. For example, if a video is largely in English and is intended for English-speaking audiences, but has a short scene in which people speak Japanese, you set the <code>audio</code> as <code>[\"en\"]</code>, not <code>[\"en\", \"ja\"]</code>.</p> <p>Order</p> <p>Language codes should always be listed in alphabetical order.</p> <p>Examples</p> <p><code>Metal Gear Solid Integral (Japan)</code> on PlayStation has English audio, selectable English or Japanese subtitles, and a mix of English and Japanese for the interface\u2014where Japanese is used for weapon and item descriptions, and English for everything else. It's a weird mix, but it's definitely intended for Japanese audiences, so it's represented as follows:</p> <pre><code>\"languages\": {\n  \"audio\": [\"en\"],\n  \"interface\": [\"ja\"],\n  \"subtitles\": [\"en\", \"ja\"]\n}\n</code></pre> <p><code>Ghost in the Shell (France)</code> on PlayStation has cutscenes where the audio is in French, but the interface is in English, and there are no subtitles. This is represented as follows:</p> <pre><code>\"languages\": {\n  \"audio\": [\"fr\"],\n  \"interface\": [\"en\"],\n  \"subtitles\": [null]\n}\n</code></pre> Expand for developer details <p>Certain combinations of language types tell us useful things. For example, a Japanese title with the following properties is completely playable by English speakers:</p> <pre><code>\"languages\": {\n  \"audio\": [null],\n  \"interface\": [\"en\"],\n  \"subtitles\": [null]\n}\n</code></pre> <p>Consider these scenarios when building filters for DAT files.</p> <p>Languages in graphical user interfaces</p> <p>These language codes are intended to keep the character count of the <code>languages</code> arrays, and therefore the file size, down. When building graphical user interfaces, opt to use full language names to keep it more accessible to users.</p> </li> <li> <p><code>sets</code> <code>object array</code> <code>required</code></p> <p>Defines the different file sets within the title. Read more about the <code>sets</code> array.</p> </li> </ul>"},{"location":"titles/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>build</code> <code>enum</code> <code>optional</code></p> <p>When in the software release life cycle the title was released. Must be one of the following values, in order of maturity and specificity:</p> <ul> <li> <p><code>Production</code>: What reaches store shelves or internet distribution systems. This   includes release to manufacturing (RTM) releases.</p> </li> <li> <p><code>Release candidate</code>: There are often multiple release candidates, of which one is   chosen to go to production. Release candidates are feature complete, and only   significant bugs force another release candidate to be issued.</p> </li> <li> <p><code>Beta</code>: A largely feature-complete version of a title, that still has bugs and   performance issues to squash.</p> </li> <li> <p><code>Alpha</code>: An in-development version of a title that isn't feature complete, and isn't   thoroughly tested. Likely to be highly buggy.</p> </li> <li> <p><code>Pre-alpha</code>: This includes early development titles and prototypes.</p> </li> <li> <p><code>Review</code>: A version of the title sent to reviewers. This can be production code,   preproduction code, or have code in it that's unique to the reviewer copy.</p> </li> <li> <p><code>Preproduction</code>: A generic catch-all for a title that is at an unspecified   development stage, but isn't the production version. Wherever possible, don't use   this.</p> </li> </ul> <p>If this property isn't present, the DAT application assumes the value is <code>Production</code>.</p> </li> <li> <p><code>contains</code> <code>object array</code> <code>optional</code></p> <p>Lists the content that this title contains. Useful for identifying the following:</p> <ul> <li>The individual titles that make up a compilation.</li> <li>The individual parts that go into game of the year or special editions.</li> <li>The multiple CDs that are superceded by a DVD rerelease of the same title.</li> </ul> <p>Compilations</p> <p>The <code>contains</code> array must be paired with <code>isCompilation: true</code> when describing compilations.</p> <p>Given the following compilation:</p> <pre><code>Some Video Game A + Some Video Game B + Some Video Game C (USA)\n</code></pre> <p>The <code>contains</code> array might look like this:</p> <pre><code>\"contains\": [\n  {\n    \"name\": \"Some Video Game A (USA)\",\n    \"groupId\": \"654321\",\n    \"languages\": {\n      \"audio\": [\"en\"],\n      \"interface\": [\"en\"],\n      \"subtitles\": [\"en\"]\n    },\n    \"version\": \"1.1\",\n    \"versionInternal\": \"1\"\n  },\n  {\n    \"name\": \"Some Video Game B (USA)\",\n    \"groupId\": \"654322\",\n    \"languages\": {\n      \"audio\": [\"en\"],\n      \"interface\": [\"en\"],\n      \"subtitles\": [\"en\"]\n    },\n    \"version\": \"1.3\",\n    \"versionInternal\": \"1\"\n  },\n  {\n    \"name\": \"Some Video Game C (USA)\",\n    \"languages\": {\n      \"audio\": [\"en\"],\n      \"interface\": [\"en\"],\n      \"subtitles\": [\"en\"]\n    },\n    \"version\": \"1.0\",\n    \"versionInternal\": \"1\"\n  }\n]\n</code></pre> <p>Each <code>contains</code> title has its own <code>languages</code> object, as individual titles within a compilation often have different language support.</p> <p>The <code>groupId</code> property links the constituent title in a compilation to the relevant group of standalone titles it belongs to, via its globally unique <code>id</code>. At comparison time during a 1G1R operation, a compilation is broken down into its constituent titles and compared against the equivalent standalone titles. The title that's ultimately selected is up to user preference, whether that be to always keep the most recent version of a title, only keep compilations if they have unique titles, or otherwise.</p> <p>Where possible, the <code>version</code> and <code>internalVersion</code> properties should be consistent with the versioning of standalone titles. In this circumstance, it is okay to reuse a <code>versionInternal</code> value that has been used by an standalone title. For example, here's the <code>Some Video Game A (USA)</code> part of the <code>contains</code> array:</p> <pre><code>{\n  \"name\": \"Some Video Game A (USA)\",\n  \"groupId\": \"654321\",\n  \"languages\": {\n    \"audio\": [\"en\"],\n    \"interface\": [\"en\"],\n    \"subtitles\": [\"en\"]\n  },\n  \"version\": \"1.1\",\n  \"versionInternal\": \"1\"\n}\n</code></pre> <p>And here's the relevant part of the standalone <code>Some Video Game A (USA)</code> entry in the DAT file:</p> <pre><code>{\n  \"group\": \"Some Video Game\",\n  \"id\": \"654321\",\n  \"titles\": [\n    {\n      \"name\": \"Some Video Game A (USA)\",\n      \"regions\": [\"US\"],\n      \"languages\": {\n        \"audio\": [\"en\"],\n        \"interface\": [\"en\"],\n        \"subtitles\": [\"en\"]\n      },\n      \"version\": \"1.1\",\n      \"versionInternal\": \"1\",\n      ...\n    }\n  ]\n}\n</code></pre> <p>Notice how the <code>version</code> and <code>versionInternal</code> fields match \u2014 this way we know the variant inside the compilation is exactly the same as the standalone title, and the DAT application will need to do more work to figure out what title to select during a 1G1R operation.</p> <p>The lack of <code>groupId</code> property for <code>Some Video Game C (USA)</code> indicates that this title is only found in the compilation. It's important to include these titles in the <code>contains</code> array, as it helps DAT applications to determine whether they should keep a compilation for its unique titles during 1G1R operations.</p> <p>Supersets</p> <p>The <code>contains</code> array must be paired with <code>isSuperset: true</code> when describing supersets.</p> <p>Given the following superset:</p> <pre><code>Some Video Game - Game of the Year Edition (USA)\n</code></pre> <p>The <code>contains</code> array might look like this:</p> <pre><code>\"contains\": [\n  {\n    \"name\": \"Some Video Game (USA)\",\n    \"includesIds\": [\"123456\", \"234567\"]\n  },\n  {\n    \"name\": \"Add-ons\",\n    \"includesIds\": [\"345678\", \"456789\", \"987654\"],\n  },\n  {\n    \"name\": \"Updates\",\n    \"includesIds\": [\"012345\", \"543210\"]\n  },\n  {\n    \"name\": \"Extra content\",\n    \"extraContent\": [\"Attack of the Bad Sequel expansion\", \"Horse armor\"]\n  }\n]\n</code></pre> <p>Where the original title, its DLC, and its updates are listed. Content that isn't found in a individual title is added as a <code>extraContent</code>.</p> <p>The <code>includesIds</code> array lists the IDs of the individual titles, add-ons, and updates that are included in the superset. The included titles must be from the same region as the superset (or include the superset's region among its regions), and the array should contain all versions of the title that are the same version or older.</p> <p>For example, the <code>includesIds</code> array for the title <code>Some Video Game (USA)</code> might include both <code>Some Video Game (USA)</code> and <code>Some Video Game (v1.1) (USA)</code>, as <code>Some Video Game - Game of the Year Edition (USA)</code> supersedes both.</p> <p>DVD releases</p> <p>The <code>contains</code> array for a DVD that has superceded a set of CDs might look like this:</p> <pre><code>\"contains\": [\n  {\n    \"name\": \"Some Video Game (Disc 1) (USA)\",\n    \"includesIds\": [\"123456\"]\n  },\n  {\n    \"name\": \"Some Video Game (Disc 2) (USA)\",\n    \"includesIds\": [\"345678\", \"456789\"]\n  },\n  {\n    \"name\": \"Some Video Game (Disc 3) (USA)\",\n    \"includesIds\": [\"012345\", \"543210\"]\n  }\n]\n</code></pre> <p>The <code>includesIds</code> array lists the IDs of the individual titles associated with each disc in the set. The CDs listed in the <code>contains</code> array should come from the same region as the DVD release. All versions of the relevant CDs should be included that were released before the DVD was.</p> </li> <li> <p><code>developer</code> <code>string</code> <code>optional</code></p> <p>The developer of the title.</p> </li> <li> <p><code>id</code> <code>string</code> <code>optional</code></p> <p>A globally unique ID for the title. Usually a database ID to ease lookups for DAT file maintainers. Might be referenced by a DAT application when finding dependencies for add-ons or updates, or when present in a <code>contains</code> array.</p> </li> <li> <p><code>isAlternate</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title is an alternate variant of a release.</p> <p>Where possible, don't use this. This is a generic property that doesn't tell the user what's different about a title compared to the original. Instead, classify the title with a property that provides more detail.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> <li> <p><code>isCompilation</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title is a compilation. When used in combination with <code>contains</code>, can be used by DAT applications to follow user preferences around keeping individual titles in preference of compilations, unless the compilation contains a unique title.</p> <p>Compilations live in their own groups, and shouldn't be grouped with their consituent titles.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> <li> <p><code>isDemo</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title is a demo.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> <li> <p><code>isLicensed</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title was sanctioned for release by a platform manufacturer, assuming there was an approval process in place.</p> <p>If this property isn't present, the DAT application assumes the value is <code>true</code>.</p> </li> <li> <p><code>isMIA</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title's digests have been verified by more than one person. If not, set the value to <code>true</code>.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> <li> <p><code>isPirate</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title contains stolen assets. Often a hack of an existing game that uses intellectual property from other games.</p> <p>If the value is <code>true</code>, <code>islicensed</code> is considered <code>false</code>, regardless of its value in the DAT file.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> <li> <p><code>isSuperset</code> <code>boolean</code> <code>optional</code></p> <p>Whether the title contains more content than the original title, or for some reason is superior to another version. For example, game of the year editions, a regional variant with uncensored content, or a DVD version of a title previously released on multiple CDs.</p> <p>In 1G1R choices, supersets are selected above normal titles, so long as they fit the user's language priorities. Superset selection is cross-regional, meaning the following situation can arise:</p> <ul> <li> <p>The user preferences USA over Europe, and wants English only titles.</p> </li> <li> <p>There are three titles available to choose from:</p> <ul> <li> <p><code>Some Video Game (USA)</code></p> </li> <li> <p><code>Some Video Game (Europe)</code></p> </li> <li> <p><code>Some Video Game - Game of the Year Edition (Europe)</code></p> </li> </ul> </li> <li> <p>Because <code>Some Video Game - Game of the Year Edition (Europe)</code> is in English, and is   a superset, it gets selected even though the user preferenced USA titles over   Europe. This gives the user the most recent version of the title with the most   content.</p> </li> </ul> <p>The following are some real world examples of where you'd want to select a title from a region that's different from user preference, due to it being a superset. For example, <code>Sonic the Hedgehog (Japan)</code> on the MegaDrive is a superset of <code>Sonic the Hedgehog (USA)</code> on the Genesis, as it features extra parallax effects and is in English. <code>Fahrenheit (Europe)</code> is a superset of <code>Indigo Prophecy (USA)</code> because it's uncensored. And there are quite a few special edition games that were only ever released in Europe, despite the base game being released in the USA.</p> <p>While most people are happy with these choices after the reasons for the selection has been explained to them, sometimes people have other use cases than just having the \"best\" variant of a title. DAT applications might choose to implement additional options for 1G1R selection like following strict region priority instead.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> <li> <p><code>localNames</code> <code>object</code> <code>optional</code></p> <p>Local names given to the title, defined by language. Often titles are recorded in databases using their romanized form instead of their original name to aid with searching for the title. Other times a title can have multiple names, and what is displayed depends on the region of the machine on which it's running.</p> <p>The <code>localNames</code> object is where these names can be kept in their original form. DAT applications can then use this data to rename files according to a user's regional preferences.</p> <p>Keys should follow the language codes found in the IANA language subtag registry. See <code>languages</code> for more details about selecting a language code.</p> <p>The following is an example of the <code>localNames</code> array:</p> <pre><code>\"localNames\": {\n  \"en\": \"Altered Beast\",\n  \"ja\": \"\u7363\u738b\u8a18\"\n}\n</code></pre> <p>Only use the title's name \u2014 don't include additional information like tags found in naming systems.</p> <p>If a title can show more than one name depending on the region, and the title <code>name</code> is already in English, you should still include the English name in the <code>localNames</code> array. This is because client applications have no idea what language the title <code>name</code> is in, and so can't safely select it as the English name if someone sets that as a preference.</p> </li> <li> <p><code>peripherals</code> <code>enum array</code> <code>optional</code></p> <p>Contains inputs used to control the title, or devices that show output from the title.</p> <p>Names are as generic as possible, with a focus on mentioning if specialist devices are required for an ideal emulation experience.</p> <p>For example, trying to play Guitar Hero with a standard controller is asking for a bad time, so it would be set to the following:</p> <pre><code>\"peripherals\": [\n  \"Guitar\"\n]\n</code></pre> <p>But playing almost any GameCube game with almost any controller through an emulator is perfectly fine, so they would generally be set to the following:</p> <pre><code>\"peripherals\": [\n  \"Controller\"\n]\n</code></pre> <p>For scenarios where titles are optimized for multiple inputs (for example, a racing game might be great with both controllers and a steering wheel), add both:</p> <pre><code>\"peripherals\": [\n  \"Controller\",\n  \"Pedals\",\n  \"Steering Wheel (Lock-to-lock)/Paddle\"\n]\n</code></pre> <p>Valid values are the following:</p> <ul> <li> <p><code>Controller</code></p> </li> <li> <p><code>Controller with Touchpad</code></p> </li> <li> <p><code>Controller with Trackball</code></p> </li> <li> <p><code>Analog Joystick</code></p> </li> <li> <p><code>Dance Pad</code></p> </li> <li> <p><code>Digital Joystick</code></p> </li> <li> <p><code>Digital Twin Sticks</code></p> </li> <li> <p><code>Drums</code></p> </li> <li> <p><code>EyeToy</code></p> </li> <li> <p><code>Flight Stick</code></p> </li> <li> <p><code>Guitar</code></p> </li> <li> <p><code>HOTAS</code></p> </li> <li> <p><code>Keyboard</code></p> </li> <li> <p><code>Light Gun</code></p> </li> <li> <p><code>Magnavox Odyssey Controller</code></p> </li> <li> <p><code>Microphone</code></p> </li> <li> <p><code>Microsoft Kinect</code></p> </li> <li> <p><code>Microsoft Xbox Live Vision</code></p> </li> <li> <p><code>Mouse</code></p> </li> <li> <p><code>Nintendo Joy-Con</code></p> </li> <li> <p><code>Nintendo Wii Balance Board</code></p> </li> <li> <p><code>Nintendo Wii Remote</code></p> </li> <li> <p><code>Nintendo Wii Remote and Nunchuk</code></p> </li> <li> <p><code>Nintendo Power Glove</code></p> </li> <li> <p><code>Pedals</code></p> </li> <li> <p><code>Sega Dreamcast VMU</code></p> </li> <li> <p><code>Sony EyeToy</code></p> </li> <li> <p><code>Sony PlayStation Eye</code></p> </li> <li> <p><code>Sony PlayStation Move</code></p> </li> <li> <p><code>Sony Sixaxis</code></p> </li> <li> <p><code>Spinner</code></p> </li> <li> <p><code>Steering Wheel (Lock-to-lock)/Paddle</code></p> </li> <li> <p><code>Steering Wheel (360\u00b0)</code></p> </li> <li> <p><code>Touchscreen</code></p> </li> <li> <p><code>Trackball</code></p> </li> <li> <p><code>VR Headset</code></p> </li> <li> <p><code>VR Headset and Controls</code></p> </li> </ul> </li> <li> <p><code>players</code> <code>int</code> <code>optional</code></p> <p>The number of players the title supports. Might be paired with <code>playModes</code>.</p> </li> <li> <p><code>playModes</code> <code>enum array</code> <code>optional</code></p> <p>The play modes the title supports. Valid values are the following:</p> <ul> <li> <p><code>Single player</code></p> </li> <li> <p><code>Co-op (Split-screen)</code></p> </li> <li> <p><code>Co-op (Local)</code></p> </li> <li> <p><code>Co-op (Remote)</code></p> </li> <li> <p><code>Competitive (Split-screen Free-for-all)</code></p> </li> <li> <p><code>Competitive (Split-screen Team)</code></p> </li> <li> <p><code>Competitive (Local Free-for-all)</code></p> </li> <li> <p><code>Competitive (Local Team)</code></p> </li> <li> <p><code>Competitive (Remote Free-for-all)</code></p> </li> <li> <p><code>Competitive (Remote Team)</code></p> </li> </ul> </li> <li> <p><code>published</code> <code>bool</code> <code>optional</code></p> <p>Whether the title was published. Unpublished titles that didn't have an official release should be set to <code>false</code>.</p> <p>If this property isn't present, the DAT application assumes the value is <code>true</code>.</p> </li> <li> <p><code>publisher</code> <code>string</code> <code>optional</code></p> <p>The publisher of the title.</p> </li> <li> <p><code>releaseDate</code> <code>pattern string</code> <code>optional</code></p> <p>The date the title was released. Must be an ISO 8601 extended format date, without the time zone. Valid formats include the following:</p> <ul> <li> <p><code>YYYY-MM-DD hh:mm:ss</code></p> </li> <li> <p><code>YYYY-MM-DD hh:mm</code></p> </li> <li> <p><code>YYYY-MM-DD</code></p> </li> <li> <p><code>YYYY-MM</code></p> </li> <li> <p><code>YYYY</code></p> </li> </ul> Expand for developer details <p>Valid dates are found with the following regular expressions:</p> <pre><code>^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]:?){1,2}(?&lt;!:)$\n^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9])$\n^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01]))$\n^[1-9][0-9]{3,3}-(?:0[1-9]|1[0-2])$\n^[1-9][0-9]{3,3}$\n</code></pre> <p>There's a lower year bound of 1000, and an upper year bound of 9999. The regular expressions also constrain month and date pairs appropriately, although it's possible to have February 29 on a non-leap year. It's assumed that systems generating the DAT file will generate valid dates to avoid this. The schema validation just enforces the format to enable easier programmatic comparisons when determining if one title is newer than another.</p> </li> <li> <p><code>serial</code> <code>string</code> <code>optional</code></p> <p>A manufacturer identifier for the title. Might be a cartridge serial, disc ring code, or otherwise.</p> </li> <li> <p><code>source</code> <code>enum array</code> <code>optional</code></p> <p>The title's origin. Valid sources are:</p> <ul> <li> <p><code>3.5\\\" floppy disk</code></p> </li> <li> <p><code>5.25\\\" floppy disk</code></p> </li> <li> <p><code>BD-ROM</code></p> </li> <li> <p><code>BD-ROM (Ultra HD)</code></p> </li> <li> <p><code>Cassette tape</code></p> </li> <li> <p><code>CD-ROM</code></p> </li> <li> <p><code>Device</code></p> </li> <li> <p><code>Digital</code></p> </li> <li> <p><code>DVD-ROM</code></p> </li> <li> <p><code>Famicom Disk</code></p> </li> <li> <p><code>GameCube Game Disc</code></p> </li> <li> <p><code>Game Card</code></p> </li> <li> <p><code>GD-ROM</code></p> </li> <li> <p><code>Hard Drive</code></p> </li> <li> <p><code>HD-DVD</code></p> </li> <li> <p><code>HuCard</code></p> </li> <li> <p><code>LaserDisc</code></p> </li> <li> <p><code>Memory Card</code></p> </li> <li> <p><code>ROM Card</code></p> </li> <li> <p><code>ROM Cartridge</code></p> </li> <li> <p><code>UMD</code></p> </li> <li> <p><code>VHS</code></p> </li> <li> <p><code>Wii Optical Disc</code></p> </li> <li> <p><code>Wii U Optical Disc</code></p> </li> </ul> </li> <li> <p><code>subtype</code> <code>enum</code> <code>optional</code></p> <p>The subtype of the title. Must be paired with a valid <code>type</code>.</p> <ul> <li> <p><code>Add-on</code> - Valid with the <code>Application</code> and <code>Game</code> types.</p> </li> <li> <p><code>Audio</code> - Valid with the <code>Application</code> and <code>Game</code> types.</p> </li> <li> <p><code>Children</code> - Valid with the <code>Application</code>, <code>Audio</code>, <code>Game</code>, <code>Multimedia</code>, and <code>Video</code> types.</p> </li> <li> <p><code>Educational</code> - Valid with the <code>Application</code>, <code>Audio</code>, <code>Game</code>, <code>Multimedia</code>, and <code>Video</code> types.</p> </li> <li> <p><code>Manual</code> - Valid with the <code>Application</code>, <code>Device</code>, and <code>Game</code> types.</p> </li> <li> <p><code>Update</code> - Valid with the <code>Application</code> and <code>Game</code> types.</p> </li> <li> <p><code>Video</code> - Valid with the <code>Application</code> and <code>Game</code> types.</p> </li> </ul> <p>For example:</p> <pre><code>\"type\": \"Game\",\n\"subtype\": \"Add-on\"\n</code></pre> </li> <li> <p><code>type</code> <code>enum</code> <code>optional</code></p> <p>The type of the title. Must be one of the following:</p> <ul> <li> <p><code>Application</code></p> </li> <li> <p><code>Audio</code></p> </li> <li> <p><code>BIOS</code></p> </li> <li> <p><code>Chip</code></p> </li> <li> <p><code>Coverdisc</code></p> </li> <li> <p><code>Device</code></p> </li> <li> <p><code>Firmware</code></p> </li> <li> <p><code>Game</code></p> </li> <li> <p><code>Magazine</code></p> </li> <li> <p><code>Multimedia</code></p> </li> <li> <p><code>Video</code></p> </li> </ul> <p>These can be paired with a <code>subtype</code>.</p> </li> <li> <p><code>version</code> <code>string</code> <code>optional</code></p> <p>The version as reported by the title or media it came on. Don't include prefixes like <code>v</code>, or <code>Rev</code>, only include the version string itself.</p> <p>For example, don't use <code>Rev 1</code>, instead use <code>1</code>. Don't use <code>v1.1a</code>, instead use <code>1.1a</code>.</p> </li> <li> <p><code>versionInternal</code> <code>int</code> <code>optional</code></p> <p>An integer-based version assigned by the DAT maintainer, so DAT applications don't have to parse multiple different versioning systems when making 1G1R decisions. This can also help fill the gap in 1G1R selection when the title's <code>releaseDate</code> is unknown.</p> <p>The earliest release is set to <code>1</code>, with later releases increasing in value.</p> <p>The following rules apply:</p> <ul> <li> <p>The <code>versionInternal</code> is regional. That is, it only applies to, and is only compared   against titles in the same region.</p> </li> <li> <p>Don't assign the same number to multiple releases within the one region.</p> </li> <li> <p>Numbering should start from the earliest available release, including preproduction.</p> </li> <li> <p>If you don't know the release order, make your best guess. It's not ideal, but it   means a 1G1R selection can actually happen.</p> </li> </ul> <p>For example:</p> <pre><code>...\n\"name\": \"Some Video Game (USA)\",\n\"versionInternal\": 1,\n...\n\"name\": \"Some Video Game (USA) (v1.1)\",\n\"versionInternal\": 2,\n...\n\"name\": \"Some Video Game (USA) (v1.2)\",\n\"versionInternal\": 3,\n...\n\"name\": \"Some Video Game (Europe) (Beta)\",\n\"versionInternal\": 1,\n...\n\"name\": \"Some Video Game (Europe)\",\n\"versionInternal\": 2,\n...\n\"name\": \"Some Video Game - Game of the Year (Europe)\",\n\"versionInternal\": 3,\n...\n</code></pre> Expand for developer details <p>This is an attempt to partially recreate how Retool sets up clone lists, while removing the need to write logic that figures out which titles are the oldest or newest. See 1G1R calculations.</p> </li> <li> <p><code>videoStandards</code> <code>enum array</code> <code>optional</code></p> <p>The video standard supported by the title. This describes a title's fixed output in both color and resolution, as opposed to any monitor standard that might be receiving the output.</p> <p>Use <code>RGB</code> for any title that supports higher resolutions than SVGA, and allows for flexible resolution output.</p> <p>Valid standards are:</p> <ul> <li> <p><code>4K Ultra HD</code></p> </li> <li> <p><code>8K Ultra HD</code></p> </li> <li> <p><code>AX-VGA</code></p> </li> <li> <p><code>CGA</code></p> </li> <li> <p><code>EGA</code></p> </li> <li> <p><code>EVGA</code></p> </li> <li> <p><code>HGC</code></p> </li> <li> <p><code>HDTV (720i)</code></p> </li> <li> <p><code>HDTV (720p)</code></p> </li> <li> <p><code>Full HDTV (1080i)</code></p> </li> <li> <p><code>Full HDTV (1080p)</code></p> </li> <li> <p><code>JEGA</code></p> </li> <li> <p><code>MCGA</code></p> </li> <li> <p><code>MDA</code></p> </li> <li> <p><code>MPAL</code></p> </li> <li> <p><code>NTSC</code></p> </li> <li> <p><code>NTSC (DV) (480i)</code></p> </li> <li> <p><code>NTSC (DV) (480p)</code></p> </li> <li> <p><code>PAL</code></p> </li> <li> <p><code>PAL (DV) (576i)</code></p> </li> <li> <p><code>PAL (DV) (576p)</code></p> </li> <li> <p><code>PAL 60Hz</code></p> </li> <li> <p><code>PGC</code></p> </li> <li> <p><code>Plantronics</code></p> </li> <li> <p><code>Quadcolor</code></p> </li> <li> <p><code>RGB</code></p> </li> <li> <p><code>SECAM</code></p> </li> <li> <p><code>SVGA</code></p> </li> <li> <p><code>Tandy</code></p> </li> <li> <p><code>TIGA</code></p> </li> <li> <p><code>VGA</code></p> </li> <li> <p><code>XGA</code></p> </li> </ul> </li> </ul>"},{"location":"top_level/","title":"Top level","text":"<p>A DAT file at the top level has minimal properties.</p> <p>In the following example, required properties are highlighted.</p> <pre><code>{\n  \"datInfo\": {\n    ...\n  },\n  \"collection\": [\n    ...\n  ]\n}\n</code></pre>"},{"location":"top_level/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>datInfo</code> <code>object</code> <code>required</code></p> <p>Contains information related to the DAT file and those who created it. It functions like a header for the file. Read more about the <code>datInfo</code> object.</p> </li> <li> <p><code>collection</code> <code>object array</code> <code>required</code></p> <p>Lists all the titles in the DAT file. Read more about the <code>collection</code> array.</p> </li> </ul>"},{"location":"updates/","title":"<code>updates</code>","text":"<p>The <code>updates</code> array contains objects that represent different updates for a <code>title</code>. You can link updates to their dependent updates and titles.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"updates\": [\n  {\n    \"name\": \"Some Video Game (USA) (Update v1.2)\",\n    \"container\": \"auto\",\n    \"requiresId\": [\"123456\", \"321653\"]\n    \"id\": \"321654\",\n    \"comments\": \"Something relevant about the update\",\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Update v1.1)\",\n    \"container\": \"auto\",\n    \"requiresId\": [\"123456\"],\n    \"id\": \"321653\",\n    \"comments\": \"Something relevant about the update\",\n    \"files\": [\n      ...\n    ]\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Update v1.01)\",\n    \"container\": \"auto\",\n    \"requiresId\": [\"123456\"],\n    \"superseded\": true,\n    \"id\": \"321652\",\n    \"comments\": \"Something relevant about the update\",\n    \"files\": [\n      ...\n    ]\n  }\n]\n</code></pre>"},{"location":"updates/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the update, in UTF-8. This is used for the name of the archive or folder of the contained update:</p> <p>Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\|?*].*[^. :&lt;&gt;\\\"\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>files</code> <code>object array</code> <code>required</code></p> <p>The files in the update and their properties. Read more about the <code>files</code> array.</p> </li> </ul>"},{"location":"updates/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>comments</code> <code>string</code> <code>optional</code></p> <p>Comments related to the update.</p> </li> <li> <p><code>container</code> <code>string</code> <code>optional</code></p> <p>The container that the DAT application should use for the file set. Must be one of the following values:</p> <ul> <li> <p><code>auto</code>: Store the files in whatever container the user chooses in the DAT   application. For example, a ZIP file, a 7Z file, a folder, or no container. The base   file name of the container matches the update <code>name</code>.</p> </li> <li> <p><code>folder</code>: Store the files in a folder named after the update   <code>name</code>.</p> </li> <li> <p><code>null</code>: Don't store the files in any container. Useful for keeping files by   themselves, or for treating archives as files.</p> </li> </ul> <p>If this property isn't present, the DAT application assumes the value is <code>auto</code>.</p> </li> <li> <p><code>id</code> <code>string</code> <code>optional</code></p> <p>A globally unique ID for the update. Usually a database ID to ease lookups for DAT file maintainers. Might be referenced by a DAT application when finding dependencies for add-ons or other updates, or when present in a <code>contains</code> array.</p> </li> <li> <p><code>requiresId</code> <code>string</code> <code>optional</code></p> <p>Which titles and updates the specific update requires to function, as identified by their globally unique IDs.</p> <p>This way if a title gets selected during filtering, its relevant updates can be selected too. Conversely, if a title gets filtered out, there's an opportunity to remove its updates as well.</p> <p>Updates are considered to be valid for all <code>sets</code>.</p> Expand for developer details <p>The most optimal behavior here is likely first walking the <code>updates</code> array for the required ID, and then on a miss going up one level to <code>collections</code>, and walking the <code>titles</code> array for the required ID.</p> </li> <li> <p><code>superseded</code> <code>boolean</code> <code>optional</code></p> <p>Updates kept for archival purposes, that are no longer required to update a title to its latest version.</p> <p>If this property isn't present, the DAT application assumes the value is <code>false</code>.</p> </li> </ul>"},{"location":"includes/files/","title":"<code>files</code>","text":"<p>The <code>files</code> array contains objects that describe the files in a file set.</p> <p>In the following example, required properties are highlighted. The values are for example only.</p> <pre><code>\"files\": [\n  {\n    \"name\": \"Some Video Game (USA) (Track 1).bin\",\n    \"size\": 10000,\n    \"digests\": {\n      \"crc32\": \"29edd0e3\",\n      \"xxh3_128\": \"1a2bf3bb0a4cd3aa94bf08b1c269423e\",\n      \"blake3\": \"c32da642c108dd42bc169dbe4094b96d4f638d2c7388fb18132429347955c7ec\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA) (Track 2).bin\",\n    \"size\": 1000,\n    \"digests\": {\n      \"crc32\": \"872f5343\",\n      \"xxh3_128\": \"b993a0619f896a101e786850967b3d90\",\n      \"blake3\": \"74277af46089c2b15aea5b193bdecdd58a2992e47b00956c678a6c070225cb18\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  },\n  {\n    \"name\": \"Some Video Game (USA).cue\",\n    \"size\": 100,\n    \"digests\": {\n      \"crc32\": \"987150b7\",\n      \"xxh3_128\": \"b7bb3254808cfc06d899854a1b58bab0\",\n      \"blake3\": \"fcbc02c56a9a5157255febeac2009a988ccd08863ff648d290fe973dffe7f88c\"\n    },\n    \"dateModified\": \"1981-12-01 13:44:22\",\n    \"header\": \"01 23 45 67 89 AB CD EF FE DC BA 98 76 54 32 10\"\n  }\n]\n</code></pre>"},{"location":"includes/files/#required-properties","title":"Required properties","text":"<ul> <li> <p><code>name</code> <code>pattern string</code> <code>required</code></p> <p>The name of the file, in UTF-8. Names can't end with a period or space, start with a path separator, or use the following invalid path characters:</p> <pre><code>:&lt;&gt;\"|?*\\\n</code></pre> <p>Path separators are represented Linux-style, with <code>/</code> instead of <code>\\</code>. Don't use absolute paths, paths are relative to a path the user sets.</p> Expand for developer details <p>Invalid path characters are found with the following regular expression:</p> <pre><code>^[^:&lt;&gt;\\\"\\\\\\\\|?*].*[^. :&lt;&gt;\\\"\\\\\\\\|?*]$\n</code></pre> <p>Non-UTF-8 characters are found with the following regular expressions:</p> <pre><code>[\\xC0-\\xC1]\n[\\xF5-\\xFF]\n\\xE0[\\x80-\\x9F]\n\\xF0[\\x80-\\x8F]\n[\\xC2-\\xDF](?![\\x80-\\xBF])\n[\\xE0-\\xEF](?![\\x80-\\xBF]{2})\n[\\xF0-\\xF4](?![\\x80-\\xBF]{3})\n(?&lt;=[\\x00-\\x7F\\xF5-\\xFF])[\\x80-\\xBF]\n(?&lt;![\\xC2-\\xDF]|[\\xE0-\\xEF]|[\\xE0-\\xEF][\\x80-\\xBF]|[\\xF0-\\xF4]|[\\xF0-\\xF4][\\x80-\\xBF]|[\\xF0-\\xF4][\\x80-\\xBF]{2})[\\x80-\\xBF]\n(?&lt;=[\\xE0-\\xEF])[\\x80-\\xBF](?![\\x80-\\xBF])\n(?&lt;=[\\xF0-\\xF4])[\\x80-\\xBF](?![\\x80-\\xBF]{2})\n(?&lt;=[\\xF0-\\xF4][\\x80-\\xBF])[\\x80-\\xBF](?![\\x80-\\xBF])\n</code></pre> </li> <li> <p><code>size</code> <code>int</code> <code>required</code></p> <p>The size of the file, in bytes.</p> </li> <li> <p><code>digests</code> <code>object</code> <code>required</code></p> <p>The digests of different hash functions. The object must contain at least one digest. The following hash functions are preferred:</p> <ul> <li> <p><code>crc32</code> (pattern string): Don't use for verifying untrusted files (not even when   combined with file size, see the developer details). However, CRC32 is still useful,   as many container formats like ZIP make the CRC32 of their internal files accessible   without them needing to be extracted. Because of this, CRC32 can be used for initial   validation that a file inside an archive is worth extracting. The extracted file   should then be tested with a more reliable hashing function to verify that it's   the correct file.</p> Expand for developer details <p>Valid CRC32 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{8,8}$\n</code></pre> <p>Don't fall into the trap of thinking CRC32 + file size is enough to verify a file is the correct one. Here are four different files from the one archive, <code>segasp.zip</code>, in MAME:</p> <pre><code>\"name\": \"fpr-24208a.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"81abd9705b6ae17bd232b9fe96f12de8\",\n  \"sha1\": \"3c32ddfb3c40be66b9fb2ba35fbfd5b534bb3da0\",\n  \"sha256\": \"db9470c83a4b17cc7441b6fe6d824a1a6e299964a4a79bf8e5e6229fd542c120\",\n  \"xxh3_128\": \"8c65f0bc5c3889a0f10d59de5125db4b\",\n  \"blake3\": \"a850810cc35294c32c970870495d8f63a1328b8ea4d0c0ddef5c56daf76255c0\"\n},\n\"name\": \"fpr-24329.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"7cf5e46dd564d3a88b4f7e24a1d57362\",\n  \"sha1\": \"d0d062a4089a2d3404df45eb015faaf7eee9b8c2\",\n  \"sha256\": \"85af02e76cde08f8ed4e02c7736af7c920157dbb7e7c5cf10606d457ae97b71c\",\n  \"xxh3_128\": \"5b8d6afb1cc5d965bad5d626c760174c\",\n  \"blake3\": \"109d5884b004dd828cf2f65be422ab75464a85847c92f74f43f3812e59fee340\"\n},\n\"name\": \"fpr-24407.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"ec790069699b0312d3e374b17d1b7e20\",\n  \"sha1\": \"fbcc3d119b47a6da4d194e3fe4a98126c7049edf\",\n  \"sha256\": \"8fb1dadbc7e2a599cbcf30338c3a6e97ef24955cc0f2ceae781169ad8223cb59\",\n  \"xxh3_128\": \"45bb3c0d4298a2472e94031d88318286\",\n  \"blake3\": \"260827d650c68f62eccf207528f6f88bfa1be0088983ea1897bb3ac02c7883f0\"\n},\n\"name\": \"fpr-24407_123.ic72\",\n\"size\": 2097152,\n\"digests\": {\n  \"crc32\": \"a738ea1c\",\n  \"md5\": \"369b9634d187fd5cd28f09397a99359a\",\n  \"sha1\": \"3f5a2fb03bbb1bd9af9fe32ad76a224c97aa9b7a\",\n  \"sha256\": \"1979ae53d47e6bb52448623fb772d86ef997d8514b11955c41de6a09ee1913cb\",\n  \"xxh3_128\": \"dae252a24f23999208cd945aded75f11\",\n  \"blake3\": \"699a9cb452239bc4d678664a78351bb90a1a007a71c2a6974a77e09db2da5446\"\n}\n</code></pre> </li> <li> <p><code>sha256</code> (pattern string): Can be used for verifying untrusted files. SHA256   should only be used by client applications if the user's processor supports hardware   acceleration of the hashing function, or if no other digests are supplied for   verifying untrusted files.</p> Expand for developer details <p>Valid SHA256 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> <li> <p><code>xxh3_128</code> (pattern string): Can be used for checksumming trusted files.</p> Expand for developer details <p>Valid XXH3 128 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>blake3</code> (pattern string): Can be used for verifying untrusted files.</p> Expand for developer details <p>Valid BLAKE3 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{64,64}$\n</code></pre> </li> </ul> <p>The following hash functions should only be used in specific circumstances:</p> <ul> <li> <p><code>md5</code> (pattern string): Legacy hashing function. Wherever possible, don't use   this. The only permissable situation is if you're converting old DAT files that   don't contain more reliable hashes, and don't possess the files yourself to rehash   them with something better. Otherwise, replace with prejudice.</p> Expand for developer details <p>Valid MD5 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{32,32}$\n</code></pre> </li> <li> <p><code>sha1</code> (pattern string): Can be used for verifying untrusted files, but prefer   SHA256 or BLAKE3 where possible. SHA1 should only be used by client applications if   the user's processor supports hardware acceleration of the hashing function, or if   no other digests are supplied for verifying untrusted files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> <li> <p><code>sha1Internal</code> (pattern string): The internal SHA-1 used only for CHD files.</p> Expand for developer details <p>Valid SHA1 digests are found with the following regular expression:</p> <pre><code>^[a-fA-F0-9]{40,40}$\n</code></pre> </li> </ul> </li> </ul>"},{"location":"includes/files/#optional-properties","title":"Optional properties","text":"<ul> <li> <p><code>dateModified</code> <code>pattern string</code> <code>optional</code></p> <p>The last modified date that should be applied by the DAT application to the file.</p> <p>Only useful for old DOS titles that used timestamps as part of their copy protection.</p> <p>The date format is as follows:</p> <pre><code>YYYY-MM-DD hh:mm:ss\n</code></pre> <p>Because FAT file systems have a time resolution of 2 seconds on last modified dates, you can only use even numbers for the seconds. For example:</p> <pre><code>1980-01-01 12:35:56\n1991-12-30 23:13:32\n1992-11-24 03:12:00\n</code></pre> <p>Files with specified <code>dateModified</code> fields must not be stored in archives that change or remove the timestamp.</p> Expand for developer details <p>You can find a valid last modified timestamp with the following regular expression:</p> <pre><code>^[1-9][0-9]{3,3}-(?:(?:0[469]|11)-(?:0[1-9]|1[0-9]|2[0-9]|30)|02-(?:0[1-9]|1[0-9]|2[0-9])|(?:0[13578]|10|12)-(?:0[1-9]|1[0-9]|2[0-9]|3[01])) (?:0[0-9]|1[0-9]|2[0-3]):(?:[0-5][0-9]):(?:[0-5][02468])(?&lt;!:)$\n</code></pre> </li> <li> <p><code>header</code> <code>string</code> <code>optional</code></p> <p>The header for a file, in hex. Aids with addition of a header to a headerless file, or removal from a headered file.</p> </li> </ul>"}]}